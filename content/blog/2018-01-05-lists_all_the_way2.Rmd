---
date: 2018-01-05
title: "It's lists all the way down, part 2: We need to go deeper"
tags: [R]
menu:
  main:
    parent: Blog
    identifier: /blog/lists_all_the_way2
    weight: 1
---

Shortly after my [previous blog post](http://www.brodrigues.co/blog/2018-01-03-lists_all_the_way/),
I saw this tweet on my timeline:

```{r, echo=FALSE}
Sys.setenv("R_ZIPCMD" = "/usr/bin/zip")
blogdown::shortcode("tweet", "948685418731487232")
```

This is a great initiative, and a big coincidence, as I just had blogged about nested lists and how
to map over them. I also said this in my previous blog post:

>There is also another function that you might want to study, modify_depth() which solves related
issues but I will end the blog post here. I might talk about it in a future blog post.

And so after I got this reply from [`@IsabellaGhement`](https://twitter.com/IsabellaGhement):

```{r, echo=FALSE}
blogdown::shortcode("tweet", "949029796788367361")
```

What else was I supposed to do than blog about `purrr::modify_depth()`?

Bear in mind that I was not really familiar with this function before writing my last blog post;
and even then, I decided to keep it for another blog post, which is this one. Which came much faster
than what I had originally planned. So I might have missed some functionality; if that's the case
don't hesitate to tweet me an example or send me an email! (bruno at brodrigues dot co)

So what is this blog post about? It's about lists, nested lists, and some things that you can do with
them. Let's use the same example as in my last post:

```{r, include = FALSE}
library(tidyverse)
```

```{r, eval=FALSE}
library(tidyverse)
```

```{r}
data(mtcars)

nice_function = function(df, param1, param2){
  df = df %>%
    filter(cyl == param1, am == param2) %>%
    mutate(result = mpg * param1 * (2 - param2))

  return(df)
}

nice_function(mtcars, 4, 0)

values_cyl = c(4, 6, 8)

values_am = c(0, 1)
```

Now that we're here, we would like to apply `nice_function()` to each element of `values_cyl` and
`values_am`. In essence, loop over these values. But because loops are not really easy to manipulate,
(as explained, in part, [here](http://blog.rdata.lu/post/2017-12-21-skip-errors-in-r-by-not-writing-loops/))
I use the `map*` family of function included in `purrr` (When I teach R, I only show loops in the
*advanced topics* chapter of my notes). So let's "loop" over `values_cyl` and `values_am` with `map()`
(and not `map_df()`; there is a reason for this, bear with me):

```{r}
(result = map(values_am, ~map(values_cyl, nice_function, df = mtcars, param2 = .)))
```

Until now, nothing new compared to my previous post (so if you have a hard time to follow what I'm
doing, go read it [here](http://www.brodrigues.co/blog/2018-01-03-lists_all_the_way/)).

As far as I know, there is no way, in this example, to avoid this nested map call. However,
suppose now that you want to apply a function to each single data frame contained in the list `result`.
Of course, here, you could simply use `bind_rows()` to have a single data frame and then apply your
function to it. But suppose that you want to keep this list structure; at the end, I will give and
example of why you might want that, using another `purrr` function, `walk()` and Thomas' J. Leeper
brililant [`rio`](https://github.com/leeper/rio) package.

So suppose you want to use this function here:

```{r}
double_col = function(dataset, col){
  col = enquo(col)
  col_name = paste0("double_", quo_name(col))
  dataset %>%
    mutate(!!col_name := 2*(!!col))
}
```

to double the values of a column of a dataset. It uses `tidyeval`'s `enquo()`, `quo_name()` and `!!()`
functions to make it work with `tidyverse` functions such as `mutate()`. You can use it like this:

```{r}
double_col(mtcars, hp)
```

Nice, but you want to use this function on all of the data frames contained in your `result` list.
You can use a nested `map()` as before:

```{r}
map(result, ~map(., .f = double_col, col = disp))
```

but there's an easier solution, which is using `modify_depth()`:

```{r}
(result = modify_depth(result, .depth = 2, double_col, col = disp))
```

So how does it work? `modify_depth()` needs a list and a `.depth` argument, which corresponds to
where you you mant to apply your function. The following lines of code might help you understand:

```{r}
# Depth of 1:

result[[1]]
```

In this example, a depth of 1 corresponds to a list of three data frame. Can you use your function
`double_col()` on a list of three data frames? No, because the domain of `double_col()` is the set
of data frames, not the set of lists of data frames. So you need to go deeper:

```{r}
# Depth of 2:

result[[1]][[1]]
```

At the depth of 2, you're dealing with data frames! So you can use your function `double_col()`.
With a depth of 2, one might not see the added value of `modify_depth()` over nested map calls, but
if you have to go even deeper, nested map calls are very confusing and verbose.

Now for the last part; why doing all this, and not simply binding all the rows, apply `double_col()`
and call it a day? Well, suppose that there is a reason you have these data frames inside lists; for
example, the first element, i.e., `result[[1]]` might be data for, say, Portugal, for 3 different years.
`result[[2]]` however, is data for France, for the same years. Suppose also that you have to give
this data, after having worked on it, to a colleague (or to another institution) in the Excel format;
one Excel workbook per country, one sheet per year. This example might seem contrived, but I have
been confronted to this exact situation very often. Well, if you bind all the rows together, how are
you going to save the data in the workbooks like you are required to?

Well, thanks to `rio`, one line of code is enough:

```{r, eval = FALSE}
library(rio)

walk2(result, list("portugal.xlsx", "france.xlsx"), export)
```

I know what you're thinking; *Bruno, that's two lines of code!*. Yes, but I had to load `rio`. Also,
`walk()` (and `walk2()`) are basically the same as `map()`, but you use `walk()` over `map()` when
you are only interested in the side effect of the function you are applying over your list; here, `export()`
which is `rio`'s function to write data to disk. The side effect of this function is... writing data to disk!
You could have used `map2()` just the same, but I wanted to show you `walk2()` (however, you cannot
replace `map()` by `walk()` in most cases; try it and see what happens).

If you enjoy these blog posts, you can follow me on [twitter](https://twitter.com/brodriguesco).
