---
date: 2018-11-10
title: "Analyzing NetHack data, part 2: What players kill the most"
tags: [R]
menu:
  main:
    parent: Blog
    identifier: /blog/nethack_analysis_part2
    weight: 1
---

<div style="text-align:center;">
  <a href="https://www.youtube.com/watch?v=VnW2g6qbbrA">
    <img src="/img/monsters.png" title = "Wizard of Yendor battle music"></a>
</div>

Link to [webscraping the data](https://www.brodrigues.co/blog/2018-11-01-nethack/)

Link to [Analysis, part 1](https://www.brodrigues.co/blog/2018-11-03-nethack_analysis/)

## Introduction

This is the third blog post that deals with data from the game NetHack, and oh boy, did a lot of 
things happen since the last blog post! Here's a short timeline of the events:

* I scraped data from [alt.org/nethack](https://alt.org/nethack/) and made a package with the data available on Github 
(that package was too big for CRAN)
* Then, I analyzed the data, focusing on what monsters kill the players the most, and also where 
players die the most
* @GridSageGames, developer of the roguelike Cogmind and moderator of the roguelike subreddit,
posted the blog post on reddit
* I noticed that actually, by scraping the data like I did, I only got a sample of 100 daily games
* This point was also discussed on Reddit, and bhhak, an UnNetHack developer (UnNetHack is a fork
of NetHack) suggested I used the xlogfiles instead
* xlogfiles are log files generated by NetHack, and are also available on alt.org/nethack
* I started scraping them, and getting a lot more data
* I got contacted on twitter by @paxed, an admin of alt.org/nethack:


```{r, echo=FALSE}
blogdown::shortcode("tweet", "1059333642592366593")
```

* He gave me access to ALL THE DATA on alt.org/nethack!
* The admins of [alt.org/nethack](https://alt.org/nethack/) will release all the data to the public!

So, I will now continue with the blog post I wanted to do in the first place; focusing now on what
roles players choose to play the most, and also which monsters they kill the most. BUT! Since all the data
will be released to the public, my `{nethack}` package that contains data that IÂ scraped is not
that useful anymore. So I changed the nature of the package. 
Now the package contains some functions: a function to parse and prepare the xlogfiles from NetHack that
you can download from [alt.org/nethack](https://alt.org/nethack/) (or from any other public server), a function
to download dumplogs such as this [one](http://archive.is/7awsb). These dumplogs contain a lot of
info that I will extract in this blog post, using another function included in the `{nethack}` package.
The package also contains a sample of 6000 runs from NetHack version 3.6.1.

You can install the package with the following command line:

```{r, eval=FALSE}
devtools::install_github("b-rodrigues/nethack")
```

## The `{nethack}` package

In [part 1](https://www.brodrigues.co/blog/2018-11-03-nethack_analysis/) I showed what killed
players the most. Here, I will focus on what monsters players kill the most. 
Let's start by loading some packages:

```{r, include=FALSE}
library(tidyverse)
library(lubridate)
library(magrittr)
library(ggridges)
library(brotools)
library(rvest)
library(nethack)
```

```{r, eval=FALSE}
library(tidyverse)
library(lubridate)
library(magrittr)
library(ggridges)
library(brotools)
library(rvest)
library(nethack)
```

Let's first describe the data:

```{r}
brotools::describe(nethack) %>% 
  print(n = Inf)
```

All these columns are included in xlogfiles. The data was prepared using two functions, included
in `{nethack}`:

```{r, eval = FALSE}
xlog <- read_delim("~/path/to/nethack361_xlog.csv", "\t", escape_double = FALSE, 
                   col_names = FALSE, trim_ws = TRUE)

xlog_df <- clean_xlog(xlog)
```

`nethack361_xlog.csv` is the raw xlogfiles that you can get from NetHack public servers.
`clean_xlog()` is a function that parses an xlogfile and returns a clean data frame.
`xlog_df` will be a data frame that will look just as the one included in `{nethack}`. It is
then possible to get the dumplog from each run included in `xlog_df` using `get_dumplog()`:

```{r, eval=FALSE}
xlog_df <- get_dumplog(xlog_df)
```

This function adds a column called `dumplog` with the dumplog of that run. I will now analyze
the dumplog file, by focusing on monsters vanquished, genocided or extinct. In a future blogpost
I will focus on other achievements.

## Roles played (and other starting stats)

I will take a look at the races, roles, gender and alignment players start with the most. I will do 
pie charts to visualize these variable, so first, let's start by writing a general function that
allows me to do just that:

```{r}
create_pie <- function(dataset, variable, repel = FALSE){

  if(repel){
    geom_label <- function(...){
      ggrepel::geom_label_repel(...)
    }
  }

  variable <- enquo(variable)

  dataset %>%
    count((!!variable)) %>%
    mutate(total = sum(n),
           freq = n/total,
           labels = scales::percent(freq)) %>% 
    arrange(desc(freq)) %>%
    ggplot(aes(x = "", y = freq, fill = (!!variable))) + 
    geom_col() + 
    geom_label(aes(label = labels), position = position_stack(vjust = 0.25), show.legend = FALSE) + 
    coord_polar("y") + 
    theme_blog() + 
    scale_fill_blog() + 
    theme(legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank())
}
```

Now I can easily plot the share of races chosen:

```{r}
create_pie(nethack, race)
```

or the share of alignment:

```{r}
create_pie(nethack, align0)
```

Same for the share of gender:

```{r}
create_pie(nethack, gender0)
```

and finally for the share of roles:

```{r}
create_pie(nethack, role, repel = TRUE) 
```

`create_pie()` is possible thanks to *tidy evaluation* in [`{ggplot2}`](https://www.tidyverse.org/articles/2018/07/ggplot2-3-0-0/),
which makes it possible to write a function that passes data frame columns down to `aes()`. Before
version 3.0 of `{ggplot2}` this was not possible, and writing such a function would have been a bit
more complicated. Now, it's as easy as pie, if I dare say.

Something else I want to look at, is the distribution of turns by role:

```{r}
nethack %>%
  filter(turns < quantile(turns, 0.98)) %>%
  ggplot(aes(x = turns, y = role, group = role, fill = role)) +
    geom_density_ridges(scale = 6, size = 0.25, rel_min_height = 0.01) + 
    theme_blog() + 
    scale_fill_blog() + 
    theme(axis.text.y = element_blank(),
          axis.title.y = element_blank())
```

I use the very cool `{ggridges}` package for that. The distribution seems to mostly be the same 
(of course, one should do a statistical test to be sure), but the one for the role "Valkyrie" 
seems to be quite different from the others. It is known that it is easier to win the game playing
as a Valkyrie, but a question remains: is it really easier as a Valkyrie, or do good players tend
to play as Valkyries more often? 

## Creatures vanquished, genocided or extinct

The dumplog lists which, and how many of which, creatures were vanquished during the run, as well
as creatures that were genocided and extinct. The player can genocide an entire species by reading
a *scroll of genocide* (or by sitting on a throne). A species gets extinct if the player manages to
kill every monster from that species (there's other ways too, but for the sake of simplicity, let's
just say that when the players kills every monster from a species, the species is extinct). 
The following lines are an extract of a dumplog:

```
"Vanquished creatures:"
"    Baalzebub"
"    Orcus"
"    Juiblex"
"the Wizard of Yendor (4 times)"
"    Pestilence (thrice)"
"    Famine"
"    Vlad the Impaler"
"  4 arch-liches"
"  an arch-lich"
"  a high priest"
"..."
"..."
"..."
"2873 creatures vanquished." 
```

If I want to analyze this, I have to first solve some problems:

* Replace "a" and "an" by "1"
* Put the digit in the string "(4 times)" in front of the name of the monster (going from "the Wizard of Yendor (4 times)" to "4 the Wizard of Yendor")
* Do something similar for "twice" and "thrice"
* Put everything into singular (for example, arch-liches into arch-lich)
* Trim whitespace
* Extract the genocided or extinct status from the dumplog too
* Finally, return a data frame with all the needed info

I wrote a function called `extracted_defeated_monsters()` and included it in the `{nethack}` package.
I discuss this function in appendix, but what it does is extracting information from dumplog files
about vanquished, genocided or extinct monsters and returns a tidy dataframe with that info. This
function has a lot of things going on inside it, so if you're interested in learning more about
regular expression and other `{tidyverse}` tricks, I really encourage you to read its source code.

I can now easily add this info to my data:

```{r, cache=TRUE}
nethack %<>%
  mutate(monsters_destroyed = map(dumplog, ~possibly(extract_defeated_monsters, otherwise = NA)(.)))
```

Let's take a look at one of them:

```{r}
nethack$monsters_destroyed[[117]]

nethack$monsters_destroyed[[117]] %>% 
  count(status)
```

The status variable tells us if that monster was genocided or extinct during that run. `status` 
equal to "NA" means vanquished.

It is now possible to look at, say, the top 15 vanquished monsters (normalized):

```{r}
nethack %>%
  filter(!is.na(monsters_destroyed)) %>%
  pull(monsters_destroyed) %>%
  bind_rows %>%
  group_by(monster) %>%
  summarise(total = sum(value)) %>%
  top_n(15) %>%
  ungroup() %>%
  mutate(norm_total = (total - min(total))/(max(total) - min(total))) %>%
  mutate(monster = fct_reorder(monster, norm_total, .desc = FALSE)) %>%
  ggplot() + 
  geom_col(aes(y = norm_total, x = monster)) + 
  coord_flip() + 
  theme_blog() + 
  scale_fill_blog() + 
  ylab("Ranking") +
  xlab("Monster")
```

In this type of graph, the most vanquished monster, "gnome" has a value of 1, and the least 
vanquished one, 0. This normalization step is also used in the pre-processing step of machine learning
algorithms. This helps convergence of the gradient descent algorithm for instance.

Monsters can also get genocided or extinct. Let's make a pie chart of the proportion of genocided
and extinct monsters (I lump monsters that are genocided or extinct less than 5% of the times
into a category called other). Because I want two pie charts, I nest the data after having grouped
it by the status variable. This is a trick I discussed in this blog [post](https://www.brodrigues.co/blog/2017-03-29-make-ggplot2-purrr/)
and that I use very often:

```{r}
nethack %>%
  filter(!is.na(monsters_destroyed)) %>%
  pull(monsters_destroyed) %>%
  bind_rows %>%
  filter(!is.na(status)) %>%
  group_by(status) %>% 
  count(monster) %>% 
  mutate(monster = fct_lump(monster, prop = 0.05, w = n)) %>% 
  group_by(status, monster) %>% 
  summarise(total_count = sum(n)) %>%
  mutate(freq = total_count/sum(total_count),
         labels = scales::percent(freq)) %>%
  arrange(desc(freq)) %>%
  group_by(status) %>%
  nest() %>%
  mutate(pie_chart = map2(.x = status,
                          .y = data,
                          ~ggplot(data = .y,
                                  aes(x = "", y = freq, fill = (monster))) + 
    geom_col() + 
    ggrepel::geom_label_repel(aes(label = labels), position = position_stack(vjust = 0.25), show.legend = FALSE) + 
    coord_polar("y") + 
    theme_blog() + 
    scale_fill_blog() + 
      ggtitle(.x) +
    theme(legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank())
  )) %>%
  pull(pie_chart)
```

That was it for this one, the graphs are not that super sexy, but the amount of work that went
into making them was quite consequent. The main reason was that parsing xlogfiles was a bit tricky, but
the main challenge was extracting information from dumplog files. This proved to be a bit more 
complicated than expected (just take a look at the source code of `extract_defeated_monsters()`
to get an idea...).

If you found this blog post useful, you might want to follow me on [twitter](https://www.twitter.com/brodriguesco) for blog post updates.


## Bonus plot

### Correct number of daily games

The daily number of games are available [here](https://alt.org/nethack/dailygames_ct.html). Let's
extract this info and remake the plot that shows the number of runs per day:

```{r}
games <- read_html("https://alt.org/nethack/dailygames_ct.html") %>%
        html_nodes(xpath = '//table') %>%
        html_table(fill = TRUE) 
```

This extracts all the tables and puts them into a list. Let's take a look at one:

```{r}
head(games[[1]])
```

Let's clean this up. 

```{r}
clean_table <- function(df){
  # Promotes first row to header
  colnames(df) <- df[1, ]
  df <- df[-1, ]
  
  # Remove column with total from the month
  df <- df[, -2]
  
  # Name the first column "month"
  
  colnames(df)[1] <- "month"
  
  # Now put it in a tidy format
  df %>%
    gather(day, games_played, -month)
}
```

Now I can clean up all the tables. I apply this function to each element of the list `games`. I
also add a year column:

```{r}
games <- map(games, clean_table) %>%
  map2_dfr(.x = ., 
       .y = seq(2018, 2001),
       ~mutate(.x, year = .y))
```

Now I can easily create the plot I wanted

```{r}
games %<>%
  mutate(date = lubridate::ymd(paste(year, month, day, sep = "-")))

ggplot(games, aes(y = games_played, x = date)) + 
  geom_point(colour = "#0f4150") + 
  geom_smooth(colour = "#82518c") + 
  theme_blog() + 
  ylab("Total games played")
```

There's actually a lot more games than 50 per day being played! 


## Appendix

### Fuzzy matching

If you take a look at the `extract_defeated_monsters()` source code, you'll see that at some point
I "singularize" monster names. I decided to deal with this singular/plural issue, "by hand", 
but also explored other possibilities, such as matching the plural nouns with the singular 
nouns fuzzily. In the end it didn't work out so well, but here's the code for future reference.

```{r}
monster_list <- read_html("https://nethackwiki.com/wiki/Monsters_(by_difficulty)") %>%
    html_nodes(".prettytable") %>% 
    .[[1]] %>%
    html_table(fill = TRUE)

monster_list %<>%
    select(monster = Name)

head(monster_list)
```

```{r}
library(fuzzyjoin)

test_vanquished <- extract_defeated_monsters(nethack$dumplog[[117]])

head(test_vanquished)
```

You can take a look at the result by expanding:

<details>
  <summary>Click to expand</summary>

```{r}
stringdist_left_join(test_vanquished, monster_list) %>% 
  count(monster.y) %>%
  print(n = Inf)
```
</details>

As you can see, some matches fail, especially for words that end in "y" in the singular, so "ies"
in plural, or "fire vortices" that does not get matched to "fire vortex". I tried all the methods
but it's either worse, or marginally better.

### Extracting info from dumplogfiles

<details>
  <summary>Click here to take a look at the source code from extract_defeated_monsters</summary>

```{r, eval=FALSE}
#' Extract information about defeated monsters from an xlogfile
#' @param xlog A raw xlogfile
#' @return A data frame with information on vanquished, genocided and extincted monsters
#' @importFrom dplyr mutate select filter bind_rows full_join
#' @importFrom tidyr separate
#' @importFrom tibble as_tibble tibble
#' @importFrom magrittr "%>%"
#' @importFrom purrr map2 possibly is_empty modify_if simplify discard
#' @importFrom readr read_lines
#' @importFrom stringr str_which str_replace_all str_replace str_trim str_detect str_to_lower str_extract_all str_extract
#' @export
#' @examples
#' \dontrun{
#' get_dumplog(xlog)
#' }
extract_defeated_monsters <- function(dumplog){

    if(any(str_detect(dumplog, "No creatures were vanquished."))){
        return(NA)
    } else {

        start <- dumplog %>% # <- dectect the start of the list
            str_which("Vanquished creatures")

        end <- dumplog %>% # <- detect the end of the list
            str_which("\\d+ creatures vanquished.")

        if(is_empty(end)){ # This deals with the situation of only one vanquished creature
            end <- start + 2
        }

        list_creatures <- dumplog[(start + 1):(end - 1)] %>% # <- extract the list
            str_replace_all("\\s+an? ", "1 ") %>% # <- replace a or an by 1
            str_trim() # <- trim white space

        # The following function first extracts the digit in the string (123 times)
        # and replaces the 1 with this digit
        # This means that: "1 the Wizard of Yendor (4 times)" becomes "4 the Wizard of Yendor (4 times)"
        str_extract_replace <- function(string){
            times <- str_extract(string, "\\d+(?=\\stimes)")
            str_replace(string, "1", times)
        }

        result <- list_creatures %>%
            # If a string starts with a letter, add a 1
            # This means that: "Baalzebub" becomes "1 Baalzebub"
            modify_if(str_detect(., "^[:alpha:]"), ~paste("1", .)) %>%
            # If the string "(twice)" is detected, replace "1" (that was added the line before) with "2"
            modify_if(str_detect(., "(twice)"), ~str_replace(., "1", "2")) %>%
            # Same for "(thrice)"
            modify_if(str_detect(., "(thrice)"), ~str_replace(., "1", "3")) %>%
            # Exctract the digit in "digit times" and replace the "1" with digit
            modify_if(str_detect(., "(\\d+ times)"), str_extract_replace) %>%
            # Replace "(times)" or "(twice)" etc with ""
            str_replace_all("\\(.*\\)", "") %>%
            str_trim() %>%
            simplify() %>%
            # Convert the resulting list to a tibble. This tibble has one column:
            # value
            # 1 Baalzebub
            # 2 dogs
            #...
            as_tibble() %>%
            # Use tidyr::separate to separate the "value" column into two columns. The extra pieces get merged
            # So for example "1 Vlad the Impaler" becomes "1" "Vlad the Impaler" instead of "1" "Vlad" which
            # would be the case without "extra = "merge""
            separate(value, into = c("value", "monster"), extra = "merge") %>%
            mutate(value = as.numeric(value)) %>%
            mutate(monster = str_to_lower(monster))

        # This function singularizes names:
        singularize_monsters <- function(nethack_data){
            nethack_data %>%
                mutate(monster = str_replace_all(monster, "mummies", "mummy"),
                       monster = str_replace_all(monster, "jellies", "jelly"),
                       monster = str_replace_all(monster, "vortices", "vortex"),
                       monster = str_replace_all(monster, "elves", "elf"),
                       monster = str_replace_all(monster, "wolves", "wolf"),
                       monster = str_replace_all(monster, "dwarves", "dwarf"),
                       monster = str_replace_all(monster, "liches", "lich"),
                       monster = str_replace_all(monster, "baluchiteria", "baluchiterium"),
                       monster = str_replace_all(monster, "homunculi", "homonculus"),
                       monster = str_replace_all(monster, "mumakil", "mumak"),
                       monster = str_replace_all(monster, "sasquatches", "sasquatch"),
                       monster = str_replace_all(monster, "watchmen", "watchman"),
                       monster = str_replace_all(monster, "zruties", "zruty"),
                       monster = str_replace_all(monster, "xes$", "x"),
                       monster = str_replace_all(monster, "s$", ""))
        }

        result <- singularize_monsters(result)
    }
    # If a player did not genocide or extinct any species, return the result:
    if(any(str_detect(dumplog, "No species were genocided or became extinct."))){
        result <- result %>%
            mutate(status = NA_character_)
        return(result)
    } else {

        # If the player genocided or extincted species, add this info:
        start <- dumplog %>% # <- dectect the start of the list
            str_which("Genocided or extinct species:") # <- sometimes this does not appear in the xlogfile

        end <- dumplog %>% # <- detect the end of the list
            str_which("Voluntary challenges")

       if(is_empty(start)){# This deals with the situation start does not exist
           start <- end - 2
       }

        list_creatures <- dumplog[(start + 1):(end - 1)] %>% # <- extract the list
            str_trim() # <- trim white space

        extinct_species <- list_creatures %>%
            str_extract_all("[:alpha:]+\\s(?=\\(extinct\\))", simplify = T) %>%
            str_trim %>%
            discard(`==`(., ""))

        extinct_species_df <- tibble(monster = extinct_species, status = "extinct")

        genocided_species_index <- list_creatures %>%
            str_detect(pattern = "extinct|species") %>%
            `!`

        genocided_species <- list_creatures[genocided_species_index]

        genocided_species_df <- tibble(monster = genocided_species, status = "genocided")

        genocided_or_extinct_df <- singularize_monsters(bind_rows(extinct_species_df, genocided_species_df))

        result <- full_join(result, genocided_or_extinct_df, by = "monster") %>%
            filter(monster != "") # <- this is to remove lines that were added by mistake, for example if start was empty

        return(result)
    }
}

```
</details> 
