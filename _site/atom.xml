<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Econometrics and Free Software</title>
 <link href="http://b-rodrigues.github.com/atom.xml" rel="self"/>
 <link href="http://b-rodrigues.github.com"/>
 <updated>2016-04-02T21:51:21+02:00</updated>
 <id>http://b-rodrigues.github.com</id>
 <author>
   <name>Bruno Rodrigues</name>
   <email>brodrigues@unistra.fr</email>
 </author>

 
 <entry>
   <title>Unit testing with R</title>
   <link href="http://b-rodrigues.github.com/2016/03/31/unit-testing-with-r"/>
   <updated>2016-03-31T00:00:00+02:00</updated>
   <id>http://b-rodrigues.github.com/2016/03/31/unit-testing-with-r</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;I&amp;#39;ve been introduced to unit testing while working with colleagues on quite a big project for which
we use Python.&lt;/p&gt;

&lt;p&gt;At first I was a bit skeptical about the need of writing unit tests, but now I must admit that I 
am seduced by the idea and by the huge time savings it allows. Naturally, I was wondering if the 
same could be achieved with R, and was quite happy to find out that it also possible to write unit
tests in R using a package called &lt;code&gt;testthat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unit tests (Not to be confused with unit root tests for time series) are small functions that test
your code and help you make sure everything is alright. I&amp;#39;m going to show how the &lt;code&gt;testthat&lt;/code&gt; 
packages works with a very trivial example, that might not do justice to the idea of
unit testing. But you&amp;#39;ll hopefully see why writing unit tests is not a waste of your time,
especially if your project gets very complex (if you&amp;#39;re writing a package for example).&lt;/p&gt;

&lt;p&gt;First, you&amp;#39;ll need to download and install &lt;code&gt;testthat&lt;/code&gt;. Some dependencies will also be installed.&lt;/p&gt;

&lt;p&gt;Now, you&amp;#39;ll need a function to test. Let&amp;#39;s suppose you&amp;#39;ve written a function that returns the
nth Fibonacci number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;Fibonacci &amp;lt;- function(n){
    a &amp;lt;- 0
    b &amp;lt;- 1
    for (i in 1:n){
        temp &amp;lt;- b
        b &amp;lt;- a
        a &amp;lt;- a + temp
    }
    return(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You then save this function in a file, let&amp;#39;s call it &lt;code&gt;fibo.R&lt;/code&gt;. What you&amp;#39;ll probably do once you&amp;#39;ve
written this function, is to try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;Fibonacci(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#39;ll see that the function returns the right result and continue programming. The idea behind
unit testing is write a bunch of functions that you can run after you make changes to your code,
just to check that everything is still running as it should.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s create a script called &lt;code&gt;test_fibo.R&lt;/code&gt; and write the following code in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;test_that(&amp;quot;Test Fibo(15)&amp;quot;,{
  phi &amp;lt;- (1 + sqrt(5))/2
  psi &amp;lt;- (1 - sqrt(5))/2
  expect_equal(Fibonacci(15), (phi**15 - psi**15)/sqrt(5))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above uses Binet&amp;#39;s formula, a closed form formula that gives the nth Fibonacci number and compares it 
our implementation of the algorithm. If you didn&amp;#39;t know about Binet&amp;#39;s formula, you could simply compute some numbers
by hand and compare them to what your function returns, for example. The function &lt;code&gt;expect_equal&lt;/code&gt; is a function from the 
package &lt;code&gt;testthat&lt;/code&gt; and does exactly what it tells. We expect the result of our implementation to be equal to the result of
Binet&amp;#39;s Formula. The file &lt;code&gt;test_fibo.R&lt;/code&gt; can contain as many tests as you need. 
Also, the file that contains the tests must start with the string &lt;code&gt;test&lt;/code&gt;, so that &lt;code&gt;testthat&lt;/code&gt; knows with files it has to run.&lt;/p&gt;

&lt;p&gt;Now, we&amp;#39;re almost done, create yet another script, let&amp;#39;s call it &lt;code&gt;run_tests.R&lt;/code&gt; and write the following code in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;library(testthat) 

source(&amp;quot;path/to/fibo.R&amp;quot;)

test_results &amp;lt;- test_dir(&amp;quot;path/to/tests&amp;quot;, reporter=&amp;quot;summary&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running these lines, and if everything goes well, you should see a message like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; library(testthat)
&amp;gt; source(&amp;quot;path/to/fibo.R&amp;quot;)
&amp;gt; test_results &amp;lt;- test_dir(&amp;quot;path/to/tests&amp;quot;, reporter=&amp;quot;summary&amp;quot;)

.
Your tests are dandy! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the small &lt;code&gt;.&lt;/code&gt; over the message? This means that one test was run successfully. You&amp;#39;ll get one dot per successful
test. If you take a look at &lt;code&gt;test_results&lt;/code&gt; you&amp;#39;ll see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; test_results
         file context          test nb failed skipped error  user system  real
1 test_fibo.R         Test Fibo(15)  1      0   FALSE FALSE 0.004      0 0.006
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#39;ll see each file and each function inside the files that were tested, and also whether the test was skipped, failed
etc. This may seem overkill for such a simple function, but imagine that you write dozens of functions that get more
and more complex over time. You might have to change a lot of lines because as time goes by you add new functionality,
but don&amp;#39;t want to break what was working. Running your unit tests each time you make changes can help you pinpoint 
regressions in your code. Unit tests can also help you start with your code. It can happen that sometimes you don&amp;#39;t
know exactly how to start; well you could start by writing a unit test that returns the result you want to have and 
then try to write the code to make that unit test pass. This is called test-driven development.&lt;/p&gt;

&lt;p&gt;I hope that this post motivated you to write unit tests and make you a better R programmer!&lt;/p&gt;

&lt;/body&gt;
</content>
 </entry>
 
 <entry>
   <title>Bootstrapping standard errors for difference-in-differences estimation with R</title>
   <link href="http://b-rodrigues.github.com/2015/11/11/bootstrapping-did-with-r"/>
   <updated>2015-11-11T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2015/11/11/bootstrapping-did-with-r</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;I’m currently working on a paper (with my colleague Vincent Vergnat who is also a Phd candidate at BETA) where I want to estimate the causal impact of the birth of a child on hourly and daily wages as well as yearly worked hours. For this we are using non-parametric difference-in-differences (henceforth DiD) and thus have to bootstrap the standard errors. In this post, I show how this is possible using the function &lt;code&gt;boot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For this we are going to replicate the example from Wooldridge’s &lt;em&gt;Econometric Analysis of Cross Section and Panel Data&lt;/em&gt; and more specifically the example on page 415. You can download the data for R &lt;a href=&quot;/assets/files/kielmc.RData&quot;&gt;here&lt;/a&gt;. The question we are going to try to answer is &lt;em&gt;how much does the price of housing decrease due to the presence of an incinerator in the neighborhood?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;First put the data in a folder and set the correct working directory and load the &lt;code&gt;boot&lt;/code&gt; library.&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;library(boot)
setwd(&amp;quot;/home/path/to/data/kiel data/&amp;quot;)
load(&amp;quot;kielmc.RData&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you need to write a function that takes the data as an argument, as well as an indices argument. This argument is used by the &lt;code&gt;boot&lt;/code&gt; function to select samples. This function should return the statistic you’re interested in, in our case, the DiD estimate.&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;run_DiD &amp;lt;- function(my_data, indices){
    d &amp;lt;- my_data[indices,]
    return(
        mean(d$rprice[d$year==1981 &amp;amp; d$nearinc==1]) - 
        mean(d$rprice[d$year==1981 &amp;amp; d$nearinc==0]) - 
        (mean(d$rprice[d$year==1978 &amp;amp; d$nearinc==1]) - 
        mean(d$rprice[d$year==1978 &amp;amp; d$nearinc==0]))
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re almost done! To bootstrap your DiD estimate you just need to use the boot function. If you have cpu with multiple cores (which you should, single core machines are quite outdated by now) you can even parallelize the bootstrapping.&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;boot_est &amp;lt;- boot(data, run_DiD, R=1000, parallel=&amp;quot;multicore&amp;quot;, ncpus = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you should just take a look at your estimates:&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;boot_est&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## ORDINARY NONPARAMETRIC BOOTSTRAP
## 
## 
## Call:
## boot(data = data, statistic = run_DiD, R = 1000, parallel = &amp;quot;multicore&amp;quot;, 
##     ncpus = 2)
## 
## 
## Bootstrap Statistics :
##     original    bias    std. error
## t1* -11863.9 -553.3393    8580.435&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These results are very similar to the ones in the book, only the standard error is higher.&lt;/p&gt;

&lt;p&gt;You can get confidence intervals like this:&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;quantile(boot_est$t, c(0.025, 0.975))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       2.5%      97.5% 
## -30186.397   3456.133&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or a t-statistic:&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;boot_est$t0/sd(boot_est$t)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -1.382669&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or the density of the replications:&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;&lt;code&gt;plot(density(boot_est$t))&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
    &lt;img src=&quot;/assets/images/density_did.png&quot; width=&quot;670&quot; height=&quot;450&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Just as in the book, we find that the DiD estimate is not significant to the 5% level.&lt;/p&gt;


&lt;/body&gt;
</content>
 </entry>
 
 <entry>
   <title>Update to Introduction to programming econometrics with R</title>
   <link href="http://b-rodrigues.github.com/2015/05/03/update-introduction-r-programming"/>
   <updated>2015-05-03T00:00:00+02:00</updated>
   <id>http://b-rodrigues.github.com/2015/05/03/update-introduction-r-programming</id>
   <content type="html">
&lt;p&gt;This semester I taught a course on applied econometrics with the R programming language. For this, I created a document that I gave to my students and shared online. This is the kind of document I would have liked to read when I first started using R. I already had some programming experience in C and Pascal but this is not necessarily the case for everyone that is confronted to R when they start learning about econometrics.&lt;/p&gt;

&lt;p&gt;This is why the beginning of the document focuses more on general programming knowledge and techniques, and then only on econometrics. People online seemed to like the document, as I’ve received some positive comments by David Smith from Revolution R (read his blog post about the document &lt;a href=&quot;http://blog.revolutionanalytics.com/2015/01/introduction-to-applied-econometrics-with-r.html&quot;&gt;here&lt;/a&gt;) and Dave Giles which links to David’s blog post &lt;a href=&quot;http://davegiles.blogspot.fr/2015/04/introduction-to-applied-econometrics.html?spref=tw&quot;&gt;here&lt;/a&gt;. People on twitter have also retweeted David’s and Dave’s tweets to their blog posts and I’ve received some requests by people to send them the PDF by email (because they live in places where Dropbox is not accessible unfortunately).&lt;/p&gt;

&lt;p&gt;The document is still a work in progress (and will probably remain so for a long time), but I’ve added some new sections about reproducible research and thought that this update could warrant a new blog post.&lt;/p&gt;

&lt;p&gt;For now, only linear models are reviewed, but I think I’ll start adding some chapters about non-linear models soonish. The goal for these notes, however, is not to re-invent the wheel: there are lots of good books about econometrics with R out there and packages that estimate a very wide range of models. What I want for these notes, is to focus more on the programming knowledge an econometrician needs, in a very broad and general sense. I want my students to understand that R is a true programming language, and that they need to use every feature offered by such a language, and not think of R as a black box into which you only type pre-programmed commands, but also be able to program their own routines.&lt;/p&gt;

&lt;p&gt;Also, I’ve made it possible to create the PDF using a Makefile. This may be useful for people that do not have access to Dropbox, but are familiar with git.&lt;/p&gt;

&lt;p&gt;You can compile the book in two ways: first download the whole repository:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone git@bitbucket.org:b-rodrigues/programmingeconometrics.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and then, with Rstudio, open the file &lt;em&gt;appliedEconometrics.Rnw&lt;/em&gt; and knit it. Another solution is to use the Makefile. Just type:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;inside a terminal (should work on GNU+Linux and OSX systems) and it should compile the document. You may get some message about “additional information” for some R packages. When these come up, just press Q on your keyboard to continue the compilation process.&lt;/p&gt;

&lt;p&gt;Get the notes here: &lt;a href=&quot;https://www.dropbox.com/s/k0tfyqlf3uxz6m2/Introduction%20to%20programming%20Econometrics%20with%20R%20-%20Draft.pdf?dl=0&quot;&gt;download&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As always, if you have questions or suggestions, do not hesitate to send me an email: &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#098;&amp;#114;&amp;#111;&amp;#100;&amp;#114;&amp;#105;&amp;#103;&amp;#117;&amp;#101;&amp;#115;&amp;#064;&amp;#117;&amp;#110;&amp;#105;&amp;#115;&amp;#116;&amp;#114;&amp;#097;&amp;#046;&amp;#102;&amp;#114;&quot;&gt;&amp;#098;&amp;#114;&amp;#111;&amp;#100;&amp;#114;&amp;#105;&amp;#103;&amp;#117;&amp;#101;&amp;#115;&amp;#064;&amp;#117;&amp;#110;&amp;#105;&amp;#115;&amp;#116;&amp;#114;&amp;#097;&amp;#046;&amp;#102;&amp;#114;&lt;/a&gt; and I sure hope you’ll find these notes useful!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Export R output to a file</title>
   <link href="http://b-rodrigues.github.com/2015/02/22/export-r-output-to-file"/>
   <updated>2015-02-22T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2015/02/22/export-r-output-to-file</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;

&lt;p&gt;Sometimes it is useful to export the output of a long-running R command. For example, you might want to run a time consuming regression just before leaving work on Friday night, but would like to get the output saved inside your Dropbox folder to take a look at the results before going back to work on Monday.&lt;/p&gt;
&lt;p&gt;This can be achieved very easily using &lt;code&gt;capture.output()&lt;/code&gt; and &lt;code&gt;cat()&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;out &amp;lt;- capture.output(summary(my_very_time_consuming_regression))

cat(&amp;quot;My title&amp;quot;, out, file=&amp;quot;summary_of_my_very_time_consuming_regression.txt&amp;quot;, sep=&amp;quot;\n&amp;quot;, append=TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;my_very_time_consuming_regression&lt;/code&gt; is an object of class &lt;code&gt;lm&lt;/code&gt; for example. I save the output of &lt;code&gt;summary(my_very_time_consuming_regression)&lt;/code&gt; as text using &lt;code&gt;capture.output&lt;/code&gt; and save it in a variable called &lt;code&gt;out&lt;/code&gt;. Finally, I save &lt;code&gt;out&lt;/code&gt; to a file called &lt;code&gt;summary_of_my_very_time_consuming_regression.txt&lt;/code&gt; with the first sentence being &lt;code&gt;My title&lt;/code&gt; (you can put anything there). The file &lt;code&gt;summary_of_my_very_time_consuming_regression.txt&lt;/code&gt; doesn’t have to already exist in your working directory. The option &lt;code&gt;sep=&amp;quot;\n&amp;quot;&lt;/code&gt; is important or else the whole output will be written in a single line. Finally, &lt;code&gt;append=TRUE&lt;/code&gt; makes sure your file won’t be overwritten; additional output will be appended to the file, which can be nice if you want to compare different versions of your model.&lt;/p&gt;

&lt;/body&gt;
</content>
 </entry>
 
 <entry>
   <title>Introduction to programming econometrics with R</title>
   <link href="http://b-rodrigues.github.com/2015/01/12/introduction-to-programming-econometrics-with-r"/>
   <updated>2015-01-12T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2015/01/12/introduction-to-programming-econometrics-with-r</id>
   <content type="html">
&lt;p&gt;This semester, I’ll be teaching an introduction to applied econometrics with R, so I’ve decided to write a very small book called “Introduction to programming Econometrics with R”. This is primarily intended for bachelor students and the focus is not much on econometric theory, but more on how to implement econometric theory into computer code, using the R programming language. It’s very basic and doesn’t cover any advanced topics in econometrics and is intended for people with 0 previous programming knowledge. It is still very rough around the edges, and it’s missing the last chapter about reproducible research, and the references, but I think it’s time to put it out there; someone else than my students may find it useful. The book’s probably full of typos and mistakes, so don’t hesitate to drop me an e-mail if you find something fishy: brodrigues@unistra.fr&lt;/p&gt;

&lt;p&gt;Also there might be some sections at the beginning that only concern my students. Just ignore that.&lt;/p&gt;

&lt;p&gt;Get it here: &lt;a href=&quot;https://www.dropbox.com/s/k0tfyqlf3uxz6m2/Introduction%20to%20programming%20Econometrics%20with%20R%20-%20Draft.pdf?dl=0&quot;&gt;download&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>R, R with Atlas, R with OpenBLAS and Revolution R Open: which is fastest?</title>
   <link href="http://b-rodrigues.github.com/2014/11/11/benchmarks-r-blas-atlas-rro"/>
   <updated>2014-11-11T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2014/11/11/benchmarks-r-blas-atlas-rro</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;

&lt;p&gt;In this short post, I benchmark different &amp;ldquo;versions&amp;rdquo; of R. I compare the execution speeds of R, R linked against OpenBLAS, R linked against ATLAS and Revolution R Open. Revolution R Open is a new open source version of R made by Revolution Analytics. It is linked against MKL and should offer huge speed improvements over vanilla R. Also, it uses every cores of your computer by default, without any change whatsoever to your code.&lt;/p&gt;

&lt;p&gt;TL;DR: Revolution R Open is the fastest of all the benchmarked versions (with R linked against OpenBLAS and ATLAS just behind), and easier to setup. &lt;/p&gt;

&lt;h2&gt;Setup&lt;/h2&gt;

&lt;p&gt;I benchmarked these different versions of R using &lt;code&gt;R-benchmark-25.R&lt;/code&gt; that you can download &lt;a href=&quot;http://r.research.att.com/benchmarks/R-benchmark-25.R&quot;&gt;here&lt;/a&gt;. This benchmark file was created by Simon Urbanek.&lt;/p&gt;

&lt;p&gt;I ran the benchmarks on my OpenSUSE 13.2 computer with a Pentium Dual-Core CPU E6500@2.93GHz with 4GB of Ram. It&amp;#39;s outdated, but it&amp;#39;s still quite fast for most of my numerical computation needs. I installed &amp;ldquo;vanilla&amp;rdquo; R from the official OpenSUSE repositories which is currently at version 3.1.2.&lt;/p&gt;

&lt;p&gt;Then, I downloaded OpenBLAS and ATLAS also from the official OpenSUSE repositories and made R use these libraries instead of its own implementation of BLAS. The way I did that is a bit hacky, but works: first, go to &lt;code&gt;/usr/lib64/R/lib&lt;/code&gt; and backup &lt;code&gt;libRblas.so&lt;/code&gt; (rename it to &lt;code&gt;libRblas.soBackup&lt;/code&gt; for instance). Then link &lt;code&gt;/usr/lib64/libopenblas.so.0&lt;/code&gt; to &lt;code&gt;/usr/lib64/R/lib/libRblas&lt;/code&gt;, and that&amp;#39;s it, R will use OpenBLAS. For ATLAS, you can do it in the same fashion, but you&amp;#39;ll find the library in &lt;code&gt;/usr/lib64/atlas/&lt;/code&gt;. These paths should be the same for any GNU/Linux distribution. For other operating systems, I&amp;#39;m sure you can find where these libraries are with Google.&lt;/p&gt;

&lt;p&gt;The last version I benchmarked was Revolution R Open. This is a new version of R released by Revolution Analytics. Revolution Analytics had their own version of R, called Revolution R, for quite some time now. They decided to release a completely free as in freedom and free as in free beer version of this product which they now renamed Revolution R Open. You can download Revolution R Open &lt;a href=&quot;http://mran.revolutionanalytics.com/download/#review&quot;&gt;here&lt;/a&gt;. You can have both &amp;ldquo;vanilla&amp;rdquo; R and Revolution R Open installed on your system. &lt;/p&gt;

&lt;h2&gt;Results&lt;/h2&gt;

&lt;p&gt;I ran the &lt;code&gt;R-benchmark-25.R&lt;/code&gt; 6 times for every version but will only discuss the 4 best runs.&lt;/p&gt;


&lt;style type=&quot;text/css&quot;&gt;
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 11px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 11px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-0ord{text-align:right}
&lt;/style&gt;
&lt;table class=&quot;tg&quot;&gt;
&lt;tr&gt;
&lt;th class=&quot;tg-031e&quot;&gt;R version&lt;/th&gt;
&lt;th class=&quot;tg-0ord&quot;&gt;Fastest run&lt;/th&gt;
&lt;th class=&quot;tg-0ord&quot;&gt;Slowest run&lt;/th&gt;
&lt;th class=&quot;tg-0ord&quot;&gt;Mean Run&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tg-031e&quot;&gt;Vanilla R&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;63.65&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;66.21&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;64.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tg-031e&quot;&gt;OpenBLAS R&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;15.63&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;18.96&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;16.94&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tg-031e&quot;&gt;ATLAS R&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;16.92&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;21.57&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;18.24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tg-031e&quot;&gt;RRO&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;14.96&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;16.08&lt;/td&gt;
&lt;td class=&quot;tg-0ord&quot;&gt;15.49&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;As you can read from the table above, Revolution R Open was the fastest of the four versions, but not significantly faster than BLAS or ATLAS R. However, RRO uses all the available cores by default, so if your code relies on a lot matrix algebra, RRO might be actually a lot more faster than OpenBLAS and ATLAS R. Another advantage of RRO is that it is very easy to install, and also works with Rstudio and is compatible with every R package to existence. &quot;Vanilla&quot; R is much slower than the other three versions, more than 3 times as slow! &lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;With other benchmarks, you could get other results, but I don&#39;t think that &quot;vanilla&quot; R could beat any of the other three versions. Whatever your choice, I recommend not using plain, &amp;ldquo;vanilla&amp;rdquo; R. The other options are much faster than standard R, and don&amp;#39;t require much work to set up. I&amp;#39;d personally recommend Revolution R Open, as it is free software and compatible with CRAN packages and Rstudio. &lt;/p&gt;

&lt;/body&gt;
</content>
 </entry>
 
 <entry>
   <title>Object Oriented Programming with R: An example with a Cournot duopoly</title>
   <link href="http://b-rodrigues.github.com/2014/04/23/r-s4-rootfinding"/>
   <updated>2014-04-23T00:00:00+02:00</updated>
   <id>http://b-rodrigues.github.com/2014/04/23/r-s4-rootfinding</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;I started reading &lt;em&gt;Applied Computational Economics &amp;amp; Finance&lt;/em&gt; by Mario J. Miranda and Paul L. Fackler. It is a very interesting book that I recommend to every one of my colleagues. The only issue I have with this book, is that the programming language they use is Matlab, which is proprietary. While there is a free as in freedom implementation of the Matlab language, namely Octave, I still prefer using R. In this post, I will illustrate one example the authors present in the book with R, using the package &lt;code&gt;rootSolve&lt;/code&gt;. &lt;code&gt;rootSolve&lt;/code&gt; implements Newtonian algorithms to find roots of functions; to specify the functions for which I want the roots, I use R&amp;#39;s Object-Oriented Programming (OOP) capabilities to build a model that returns two functions. This is optional, but I found that it was a good example to illustrate OOP, even though simpler solutions exist, one of which was proposed by reddit user TheDrownedKraken (whom I thank) and will be presented at the end of the article.&lt;/p&gt;

&lt;h3&gt;Theoretical background&lt;/h3&gt;

&lt;p&gt;The example is taken from Miranda&amp;#39;s and Fackler&amp;#39;s book, on page 35. The authors present a Cournot duopoly model. In a Cournot duopoly model, two firms compete against each other by quantities. Both produce a certain quantity of an homogenous good, and take the quantity produce by their rival as given. &lt;/p&gt;

&lt;p&gt;The inverse demand of the good is :&lt;/p&gt;

&lt;img src=&quot;http://latex.codecogs.com/png.latex?P(q) = q^{-\dfrac{1}{\eta}&quot; alt=&quot;P(q) = q^{-\dfrac{1}{\eta}&quot; /&gt;

&lt;p&gt;the cost function for firm i is:&lt;/p&gt;

&lt;img src=&quot;http://latex.codecogs.com/png.latex?C_i(q_i) = P(q_1+q_2)*q_i - C_i(q_i)&quot; alt=&quot;C_i(q_i) = P(q_1+q_2)*q_i - C_i(q_i)}&quot; /&gt;


&lt;p&gt;and the profit for firm i:&lt;/p&gt;

&lt;img src=&quot;http://latex.codecogs.com/png.latex?\pi_i(q1,q2) = P(q_1+q_2)q_i - C_i(q_i)&quot; alt=&quot;\pi_i(q1,q2) = P(q_1+q_2)q_i - C_i(q_i)&quot; /&gt;

&lt;p&gt;The optimality condition for firm i is thus:&lt;/p&gt;

&lt;img src=&quot;http://latex.codecogs.com/png.latex?\dfrac{\partial \pi_i}{\partial q_i} = (q1+q2)^{-\dfrac{1}{\eta}} - \dfrac{1}{\eta} (q_1+q_2)^{\dfrac{-1}{\eta-1}}q_i - c_iq_i=0.&quot; alt=&quot;\dfrac{\partial \pi_i}{\partial q_i} = (q1+q2)^{-\dfrac{1}{\eta}} - \dfrac{1}{\eta} (q_1+q_2)^{\dfrac{-1}{\eta-1}}q_i - c_iq_i=0.&quot; /&gt;


&lt;h3&gt;Implementation in R&lt;/h3&gt;

&lt;p&gt;If we want to find the optimal quantities &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_1&quot; alt=&quot;\inline q_1&quot; /&gt;  and  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_2&quot; alt=&quot;\inline q_2&quot; /&gt; we need to program the optimality condition and we could also use the jacobian of the optimality condition. The jacobian is generally useful to speed up the root finding routines. This is were OOP is useful. Firt let&amp;#39;s create a new class, called &lt;em&gt;Model&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;setClass(Class = &amp;quot;Model&amp;quot;, slots = list(OptimCond = &amp;quot;function&amp;quot;, JacobiOptimCond = &amp;quot;function&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This new class has two &lt;em&gt;slots&lt;/em&gt;, which here are functions (in general &lt;em&gt;slots&lt;/em&gt; are properties of your class); we need the model to return the optimality condition and the jacobian of the optimality condition.&lt;/p&gt;

&lt;p&gt;Now we can create a function which will return these two functions for certain values of the parameters, &lt;em&gt;c&lt;/em&gt; and  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline \eta&quot; alt=&quot;\inline \eta&quot; /&gt; of the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_mod &amp;lt;- function(eta, c) {
    e = -1/eta

    OptimCond &amp;lt;- function(q) {
        return(sum(q)^e + e * sum(q)^(e - 1) * q - diag(c) %*% q)
    }

    JacobiOptimCond &amp;lt;- function(q) {
        return((e * sum(q)^e) * array(1, c(2, 2)) + (e * sum(q)^(e - 1)) * diag(1, 
            2) + (e - 1) * e * sum(q)^(e - 2) * q * c(1, 1) - diag(c))
    }

    return(new(&amp;quot;Model&amp;quot;, OptimCond = OptimCond, JacobiOptimCond = JacobiOptimCond))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;code&gt;my_mod&lt;/code&gt; takes two parameters, &lt;code&gt;eta&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; and returns two functions, the optimality condition and the jacobian of the optimality condition. Both are now accessible via &lt;code&gt;my_mod(eta=1.6,c = c(0.6,0.8))@OptimCond&lt;/code&gt; and &lt;code&gt;my_mod(eta=1.6,c = c(0.6,0.8))@JacobiOptimCond&lt;/code&gt; respectively (and by specifying values for &lt;code&gt;eta&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now, we can use the &lt;code&gt;rootSolve&lt;/code&gt; package to get the optimal values  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_1&quot; alt=&quot;\inline q_1&quot; /&gt;  and  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_2&quot; alt=&quot;\inline q_2&quot; /&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;library(&amp;quot;rootSolve&amp;quot;)

multiroot(f = my_mod(eta = 1.6, c = c(0.6, 0.8))@OptimCond, start = c(1, 1), 
    maxiter = 100, jacfunc = my_mod(eta = 1.6, c = c(0.6, 0.8))@JacobiOptimCond)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## $root
## [1] 0.8396 0.6888
## 
## $f.root
##            [,1]
## [1,] -2.220e-09
## [2,]  9.928e-09
## 
## $iter
## [1] 4
## 
## $estim.precis
## [1] 6.074e-09
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After 4 iterations, we get that  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_1&quot; alt=&quot;\inline q_1&quot; /&gt;  and  &lt;img src=&quot;http://latex.codecogs.com/png.latex?\inline q_2&quot; alt=&quot;\inline q_2&quot; /&gt; are equal to 0.84 and 0.69 respectively, which are the same values as in the book!&lt;/p&gt;

&lt;h3&gt;Suggestion by Reddit user, TheDrownedKraken&lt;/h3&gt;

&lt;p&gt;I posted this article on rstats subbreddit on &lt;a href=&quot;http://www.reddit.com&quot;&gt;www.reddit.com&lt;/a&gt;. I got a very useful comment by reddit member TheDrownedKraken which suggested the following approach, which doesn&amp;#39;t need a new class to be build. I thank him for this. Here is his suggestion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;generator &amp;lt;- function(eta, a) {
    e = -1/eta

    OptimCond &amp;lt;- function(q) {
        return(sum(q)^e + e * sum(q)^(e - 1) * q - diag(a) %*% q)
    }

    JacobiOptimCond &amp;lt;- function(q) {
        return((e * sum(q)^e) * array(1, c(2, 2)) + (e * sum(q)^(e - 1)) * diag(1, 
            2) + (e - 1) * e * sum(q)^(e - 2) * q * c(1, 1) - diag(a))
    }

    return(list(OptimCond = OptimCond, JacobiOptimCond = JacobiOptimCond))

}

f.s &amp;lt;- generator(eta = 1.6, a = c(0.6, 0.8))

multiroot(f = f.s$OptimCond, start = c(1, 1), maxiter = 100, jacfunc = f.s$JacobiOptimCond)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## $root
## [1] 0.8396 0.6888
## 
## $f.root
##            [,1]
## [1,] -2.220e-09
## [2,]  9.928e-09
## 
## $iter
## [1] 4
## 
## $estim.precis
## [1] 6.074e-09
&lt;/code&gt;&lt;/pre&gt;


&lt;/body&gt;

</content>
 </entry>
 
 <entry>
   <title>Using R as a Computer Algebra System with Ryacas</title>
   <link href="http://b-rodrigues.github.com/2013/12/31/r-cas"/>
   <updated>2013-12-31T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2013/12/31/r-cas</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;R is used to perform statistical analysis and doesn&amp;#39;t focus on symbolic maths. But it is sometimes useful to let the computer derive a function for you (and have the analytic expression of said derivative), but maybe you don&amp;#39;t want to leave your comfy R shell. It is possible to turn R into a full-fledged computer algebra system. CASs are tools that perform symbolic operations, such as getting the expression of the derivative of a user-defined (and thus completely arbitrary) function. Popular CASs include the proprietary Mathematica and Maple. There exists a lot of CASs under a Free Software license, Maxima (based on the very old Macsyma), Yacas, Xcas&amp;hellip; In this post I will focus on Yacas and the &lt;code&gt;Ryacas&lt;/code&gt; libarary. There is also the possibility to use the &lt;code&gt;rSympy&lt;/code&gt; library that uses the &lt;code&gt;Sympy&lt;/code&gt; Python library, which has a lot more features than Yacas. However, depending on your operating system installation can be tricky as it also requires &lt;code&gt;rJava&lt;/code&gt; as a dependency. &lt;/p&gt;

&lt;p&gt;Even though &lt;code&gt;Ryacas&lt;/code&gt; is quite nice to have, there are some issues though. For example, let&amp;#39;s say you want the first derivative of a certain function f. If you use &lt;code&gt;Ryacas&lt;/code&gt; to get it, the returned object won&amp;#39;t be a function. There is a way to &amp;ldquo;extract&amp;rdquo; the text from the returned object and make a function out of it. But there are still other issues; I&amp;#39;ll discuss them later.&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;Installation should be rather painless. On Linux you need to install Yacas first, which should be available in the major distros&amp;#39; repositories. Then you can install &lt;code&gt;Ryacas&lt;/code&gt; from within the R shell. On Windows, you need to run these three commands (don&amp;#39;t bother installing Yacas first):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(&amp;#39;Ryacas&amp;#39;)
library(Ryacas)
yacasInstall()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find more information on the &lt;a href=&quot;https://code.google.com/p/ryacas/#INSTALLATION&quot;&gt;project&amp;#39;s page&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Example session&lt;/h2&gt;

&lt;p&gt;First, you must load &lt;code&gt;Ryacas&lt;/code&gt; and define symbols that you will use in your functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;require(&amp;quot;Ryacas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Loading required package: Ryacas Loading required package: XML
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;x &amp;lt;- Sym(&amp;quot;x&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then define your fonctions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_func &amp;lt;- function(x) {
    return(x/(x^2 + 3))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you can get the derivative for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_deriv &amp;lt;- yacas(deriv(my_func(x), x))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Starting Yacas!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you check the class of &lt;code&gt;my_deriv&lt;/code&gt;, you&amp;#39;ll see that it is of class &lt;code&gt;yacas&lt;/code&gt;, which is not very useful. Let&amp;#39;s «convert» it to a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_deriv2 &amp;lt;- function(x) {
    eval(parse(text = my_deriv$YacasForm))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then evaluate it. A lot of different operations are possible. But there are some problems.&lt;/p&gt;

&lt;h2&gt;Issues with Ryacas&lt;/h2&gt;

&lt;p&gt;You can&amp;#39;t use elements of a vector as parameters of your function, i.e.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;theta &amp;lt;- Sym(&amp;quot;theta&amp;quot;)
func &amp;lt;- function(x) {
    return(theta[1] * x + theta[2])
}
# Let&amp;#39;s integrate this
Func &amp;lt;- yacas(Integrate(func(x), x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;returns &lt;code&gt;(x^2*theta)/2+NA*x;&lt;/code&gt; which is not quite what we want&amp;hellip;there is a workaround however. Define your functions like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;a &amp;lt;- Sym(&amp;quot;a&amp;quot;)
b &amp;lt;- Sym(&amp;quot;b&amp;quot;)
func2 &amp;lt;- function(x) {
    return(a * x + b)
}
# Let&amp;#39;s integrate this
Func2 &amp;lt;- yacas(Integrate(func2(x), x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we get the expected result: &lt;code&gt;(x^2*a)/2+b*x;&lt;/code&gt;. Now replace &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; by the thetas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;Func2 &amp;lt;- gsub(&amp;quot;a&amp;quot;, &amp;quot;theta[1]&amp;quot;, Func2$YacasForm)
Func2 &amp;lt;- gsub(&amp;quot;b&amp;quot;, &amp;quot;theta[2]&amp;quot;, Func2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have what we want: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;Func2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;(x^2*theta[1])/2+theta[2]*x;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then copy-paste this result into a function.&lt;/p&gt;

&lt;p&gt;Another problem is if you use built-in functions that are different between R and Yacas. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_log &amp;lt;- function(x) {
    return(sin(log(2 + x)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now try to differentiate it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;dmy_log &amp;lt;- yacas(deriv(my_log(x), x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you get: &lt;code&gt;Cos(Ln(x+2))/(x+2);&lt;/code&gt;. The problem with this, is that R doesn&amp;#39;t recognize &lt;code&gt;Cos&lt;/code&gt; as the cosine (which is &lt;code&gt;cos&lt;/code&gt; in R) and the same goes for &lt;code&gt;Ln&lt;/code&gt;. These are valid Yacas functions, but that is not the case in R. So you&amp;#39;ll have to use &lt;code&gt;gsub&lt;/code&gt; to replace these functions and then copy paste the end result into a function.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While it has some flaws, &lt;code&gt;Ryacas&lt;/code&gt; can be quite useful if you need to derive or integrate complicated expressions that you then want to use in R. Using some of the tricks I showed here, you should be able to overcome some of its shortcomings. If installation of &lt;code&gt;rJava&lt;/code&gt; and thus &lt;code&gt;rSympy&lt;/code&gt; becomes easier, I&amp;#39;ll probably also do a short blog-post about it, as it has more features than &lt;code&gt;Ryacas&lt;/code&gt;.&lt;/p&gt;

&lt;/body&gt;

</content>
 </entry>
 
 <entry>
   <title>Nonlinear Gmm with R - Example with a logistic regression</title>
   <link href="http://b-rodrigues.github.com/2013/11/07/gmm-with-rmd"/>
   <updated>2013-11-07T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2013/11/07/gmm-with-rmd</id>
   <content type="html">
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- MathJax scripts --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;In this post, I will explain how you can use the R &lt;code&gt;gmm&lt;/code&gt; package to estimate a non-linear model, and more specifically a logit model. For my research, I have to estimate Euler equations using the Generalized Method of Moments. I contacted Pierre Chaussé, the creator of the &lt;code&gt;gmm&lt;/code&gt; library for help, since I was having some difficulties. I am very grateful for his help (without him, I&amp;#39;d still probably be trying to estimate my model!).&lt;/p&gt;

&lt;h3&gt;Theoretical background, motivation and data set&lt;/h3&gt;

&lt;p&gt;I will not dwell in the theory too much, because you can find everything you need &lt;a href=&quot;https://en.wikipedia.org/wiki/Generalized_method_of_moments&quot;&gt;here&lt;/a&gt;. I think it&#39;s more interesting to try to understand why someone would use the Generalized Method of Moments instead of maximization of the log-likelihood. Well, in some cases, getting the log-likelihood can be quite complicated, as can be the case for arbitrary, non-linear models (for example if you want to estimate the parameters of a very non-linear utility function). Also, moment conditions can sometimes be readily available, so using GMM instead of MLE is trivial. And finally, GMM is... well, a very general method: every popular estimator can be obtained as a special case of the GMM estimator, which makes it quite useful.&lt;/p&gt;

&lt;p&gt;Another question that I think is important to answer is: why this post? Well, because that&#39;s exactly the kind of post I would have loved to have found 2 months ago, when I was beginning to work with the GMM. Most posts I found presented the &lt;code&gt;gmm&lt;/code&gt; package with very simple and trivial examples, which weren&#39;t very helpful. The example presented below is not very complicated per se, but much more closer to a real-world problem than most stuff that is out there. At least, I hope you will find it useful!&lt;/p&gt;

&lt;p&gt;For illustration purposes, I&amp;#39;ll use data from Marno Verbeek&amp;#39;s &lt;em&gt;A guide to modern Econometrics&lt;/em&gt;, used in the illustration on page 197. You can download the data from the book&amp;#39;s companion page &lt;a href=&quot;http://www.econ.kuleuven.ac.be/gme/&quot;&gt;here&lt;/a&gt; under the section &lt;em&gt;Data sets&lt;/em&gt; or from the &lt;code&gt;Ecdat&lt;/code&gt; package in R. I use the data set from Gretl though, as the dummy variables are numeric (instead of class &lt;code&gt;factor&lt;/code&gt;) which makes life easier when writing your own functions. You can get the data set &lt;a href=&quot;/assets/files/benefits.R&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;h3&gt;Implementation in R&lt;/h3&gt;

&lt;p&gt;I don&amp;#39;t estimate the exact same model, but only use a subset of the variables available in the data set. Keep in mind that this post is just for illustration purposes.&lt;/p&gt;

&lt;p&gt;First load the &lt;code&gt;gmm&lt;/code&gt; package and load the data set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;require(&amp;quot;gmm&amp;quot;)
data &amp;lt;- read.table(&amp;quot;path/to/data/benefits.R&amp;quot;, header = T)

attach(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then estimate a logit model with the &lt;code&gt;glm()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;native &amp;lt;- glm(y ~ age + age2 + dkids + dykids + head + male + married + rr +  rr2, family = binomial(link = &amp;quot;logit&amp;quot;), na.action = na.pass)

summary(native)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = y ~ age + age2 + dkids + dykids + head + male + 
##     married + rr + rr2, family = binomial(link = &amp;quot;logit&amp;quot;), na.action = na.pass)
## 
## Deviance Residuals: 
##    Min      1Q  Median      3Q     Max  
## -1.889  -1.379   0.788   0.896   1.237  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&amp;gt;|z|)   
## (Intercept) -1.00534    0.56330   -1.78   0.0743 . 
## age          0.04909    0.02300    2.13   0.0328 * 
## age2        -0.00308    0.00293   -1.05   0.2924   
## dkids       -0.10922    0.08374   -1.30   0.1921   
## dykids       0.20355    0.09490    2.14   0.0320 * 
## head        -0.21534    0.07941   -2.71   0.0067 **
## male        -0.05988    0.08456   -0.71   0.4788   
## married      0.23354    0.07656    3.05   0.0023 **
## rr           3.48590    1.81789    1.92   0.0552 . 
## rr2         -5.00129    2.27591   -2.20   0.0280 * 
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 6086.1  on 4876  degrees of freedom
## Residual deviance: 5983.9  on 4867  degrees of freedom
## AIC: 6004
## 
## Number of Fisher Scoring iterations: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes the interesting part: how can you estimate such a non-linear model with the &lt;code&gt;gmm()&lt;/code&gt; function from the &lt;code&gt;gmm&lt;/code&gt; package? &lt;/p&gt;

&lt;p&gt;For every estimation with the Generalized Method of Moments, you will need valid moment conditions. It turns out that in the case of the logit model, this moment condition is quite simple:&lt;/p&gt;

$$ 
E[X&#39; * (Y-\Lambda(X&#39;\theta))] = 0
$$

&lt;p&gt;where \( \Lambda() \) is the logistic function. Let&amp;#39;s translate this condition into code. First, we need the logistic function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;logistic &amp;lt;- function(theta, data) {
    return(1/(1 + exp(-data %*% theta)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and let&amp;#39;s also define a new data frame, to make our life easier with the moment conditions (don&#39;t forget to add a column of ones to the matrix, hence the &lt;code&gt;1&lt;/code&gt; after &lt;code&gt;y&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;dat &amp;lt;- data.matrix(cbind(y, 1, age, age2, dkids, dykids, head, male, married, 
    rr, rr2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now the moment condition itself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;moments &amp;lt;- function(theta, data) {
    y &amp;lt;- as.numeric(data[, 1])
    x &amp;lt;- data.matrix(data[, 2:11])
    m &amp;lt;- x * as.vector((y - logistic(theta, x)))
    return(cbind(m))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The moment condition(s) are given by a function which returns a matrix with as many columns as moment conditions (same number of columns as parameters for just-identified models).&lt;/p&gt;

&lt;p&gt;To use the &lt;code&gt;gmm()&lt;/code&gt; function to estimate our model, we need to specify some initial values to get the maximization routine going. One neat trick is simply to use the coefficients of a linear regression; I found it to work well in a lot of situations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;init &amp;lt;- (lm(y ~ age + age2 + dkids + dykids + head + male + married + rr + rr2))$coefficients
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we have everything to use &lt;code&gt;gmm()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;r&quot;&gt;my_gmm &amp;lt;- gmm(moments, x = dat, t0 = init, type = &amp;quot;iterative&amp;quot;, crit = 1e-25, wmatrix = &amp;quot;optimal&amp;quot;, method = &amp;quot;Nelder-Mead&amp;quot;, control = list(reltol = 1e-25, maxit = 20000))

summary(my_gmm)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Call:
## gmm(g = moments, x = dat, t0 = init, type = &amp;quot;iterative&amp;quot;, wmatrix = &amp;quot;optimal&amp;quot;, 
##     crit = 1e-25, method = &amp;quot;Nelder-Mead&amp;quot;, control = list(reltol = 1e-25, 
##         maxit = 20000))
## 
## 
## Method:  iterative 
## 
## Kernel:  Quadratic Spectral
## 
## Coefficients:
##              Estimate    Std. Error  t value     Pr(&amp;gt;|t|)  
## (Intercept)  -0.9090571   0.5751429  -1.5805761   0.1139750
## age           0.0394254   0.0231964   1.6996369   0.0891992
## age2         -0.0018805   0.0029500  -0.6374640   0.5238227
## dkids        -0.0994031   0.0842057  -1.1804799   0.2378094
## dykids        0.1923245   0.0950495   2.0234150   0.0430304
## head         -0.2067669   0.0801624  -2.5793498   0.0098987
## male         -0.0617586   0.0846334  -0.7297189   0.4655620
## married       0.2358055   0.0764071   3.0861736   0.0020275
## rr            3.7895781   1.8332559   2.0671300   0.0387219
## rr2          -5.2849002   2.2976075  -2.3001753   0.0214383
## 
## J-Test: degrees of freedom is 0 
##                 J-test               P-value            
## Test E(g)=0:    0.00099718345776501  *******            
## 
## #############
## Information related to the numerical optimization
## Convergence code =  10 
## Function eval. =  17767 
## Gradian eval. =  NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please, notice the options &lt;code&gt;crit=1e-25,method=&amp;quot;Nelder-Mead&amp;quot;,control=list(reltol=1e-25,maxit=20000)&lt;/code&gt;: these options mean that the Nelder-Mead algorithm is used, and to specify further options to the Nelder-Mead algorithm, the &lt;code&gt;control&lt;/code&gt; option is used. This is very important, as Pierre Chaussé explained to me: non-linear optimization is an art, and most of the time the default options won&amp;#39;t cut it and will give you false results. To add insult to injury, the Generalized Method of Moments itself is very capricious and you will also have to play around with different initial values to get good results. As you can see, the Convergence code equals 10, which is a code specific to the Nelder-Mead method which indicates «degeneracy of the Nelder–Mead simplex.» . I&#39;m not sure if this is a bad thing though, but other methods can give you better results. I&#39;d suggest you try always different maximization routines with different starting values to see if your estimations are robust. Here, the results are very similar to what we obtained with the built-in function &lt;code&gt;glm()&lt;/code&gt; so we can stop here.&lt;/p&gt;


&lt;p&gt;Should you notice any error whatsoever, do not hesitate to tell me.&lt;/p&gt;

&lt;/body&gt;

</content>
 </entry>
 
 <entry>
   <title>Method of Simulated Moments with R</title>
   <link href="http://b-rodrigues.github.com/2013/01/29/method-of-simulated-moments-with-r"/>
   <updated>2013-01-29T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2013/01/29/method-of-simulated-moments-with-r</id>
   <content type="html">
&lt;p&gt;Second update on my research, details &lt;a href=&quot;/pages/Research.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Simulated Maximum Likelihood with R</title>
   <link href="http://b-rodrigues.github.com/2013/01/16/simulated-maximum-likelihood-with-r"/>
   <updated>2013-01-16T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2013/01/16/simulated-maximum-likelihood-with-r</id>
   <content type="html">
&lt;p&gt;First update on my research, details &lt;a href=&quot;/pages/Research.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>New website!</title>
   <link href="http://b-rodrigues.github.com/2012/12/11/new-website"/>
   <updated>2012-12-11T00:00:00+01:00</updated>
   <id>http://b-rodrigues.github.com/2012/12/11/new-website</id>
   <content type="html">
&lt;p&gt;This is my new website! It’s built using jekyll-bootstrap and hosted on Github.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>