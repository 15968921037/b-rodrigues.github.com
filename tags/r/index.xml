<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Econometrics and Free Software</title>
    <link>/tags/r/index.xml</link>
    <description>Recent content in R on Econometrics and Free Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Lesser known dplyr 0.7* tricks</title>
      <link>/blog/2017-06-19-dplyr-0-70-tutorial/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-06-19-dplyr-0-70-tutorial/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;This blog post is an update to an older &lt;a href=&#34;http://www.brodrigues.co/blog/2017-02-17-lesser_known_tricks/&#34;&gt;one&lt;/a&gt; I wrote in March. In the post from March, &lt;code&gt;dplyr&lt;/code&gt; was at version 0.50, but since then a major update introduced some changes that make some of the tips in that post obsolete. So here I revisit the blog post from March by using &lt;code&gt;dplyr&lt;/code&gt; 0.70.&lt;/p&gt;
&lt;div id=&#34;create-new-columns-with-mutate-and-case_when&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Create new columns with &lt;code&gt;mutate()&lt;/code&gt; and &lt;code&gt;case_when()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The basic things such as selecting columns, renaming them, filtering, etc did not change with this new version. What did change however is creating new columns using &lt;code&gt;case_when()&lt;/code&gt;. First, load &lt;code&gt;dplyr&lt;/code&gt; and the &lt;code&gt;mtcars&lt;/code&gt; dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;dplyr&amp;quot;)
data(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This was how it was done in version 0.50 (notice the ‘.$’ symbol before the variable ‘carb’):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    mutate(carb_new = case_when(.$carb == 1 ~ &amp;quot;one&amp;quot;,
                                .$carb == 2 ~ &amp;quot;two&amp;quot;,
                                .$carb == 4 ~ &amp;quot;four&amp;quot;,
                                 TRUE ~ &amp;quot;other&amp;quot;)) %&amp;gt;% 
    head(5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    mpg cyl disp  hp drat    wt  qsec vs am gear carb carb_new
## 1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4     four
## 2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4     four
## 3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1      one
## 4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1      one
## 5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2      two&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has been simplified to:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    mutate(carb_new = case_when(carb == 1 ~ &amp;quot;one&amp;quot;,
                                carb == 2 ~ &amp;quot;two&amp;quot;,
                                carb == 4 ~ &amp;quot;four&amp;quot;,
                                TRUE ~ &amp;quot;other&amp;quot;)) %&amp;gt;% 
    head(5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    mpg cyl disp  hp drat    wt  qsec vs am gear carb carb_new
## 1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4     four
## 2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4     four
## 3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1      one
## 4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1      one
## 5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2      two&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No need for &lt;code&gt;.$&lt;/code&gt; anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;apply-a-function-to-certain-columns-only-by-rows-with-purrrlyr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Apply a function to certain columns only, by rows, with &lt;code&gt;purrrlyr&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dplyr&lt;/code&gt; wasn’t the only package to get an overhaul, &lt;code&gt;purrr&lt;/code&gt; also got the same treatment.&lt;/p&gt;
&lt;p&gt;In the past, I applied a function to certains columns like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
    select(am, gear, carb) %&amp;gt;%
    purrr::by_row(sum, .collate = &amp;quot;cols&amp;quot;, .to = &amp;quot;sum_am_gear_carb&amp;quot;) -&amp;gt; mtcars2
head(mtcars2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;by_row()&lt;/code&gt; does not exist in &lt;code&gt;purrr&lt;/code&gt; anymore, but instead a new package called &lt;code&gt;purrrlyr&lt;/code&gt; was introduced with functions that don’t really fit inside &lt;code&gt;purrr&lt;/code&gt; nor &lt;code&gt;dplyr&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
    select(am, gear, carb) %&amp;gt;%
    purrrlyr::by_row(sum, .collate = &amp;quot;cols&amp;quot;, .to = &amp;quot;sum_am_gear_carb&amp;quot;) -&amp;gt; mtcars2
head(mtcars2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
##      am  gear  carb sum_am_gear_carb
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
## 1     1     4     4                9
## 2     1     4     4                9
## 3     1     4     1                6
## 4     0     3     1                4
## 5     0     3     2                5
## 6     0     3     1                4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Think of &lt;code&gt;purrrlyr&lt;/code&gt; as &lt;code&gt;purrr&lt;/code&gt;s and &lt;code&gt;dplyr&lt;/code&gt;s love child.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-dplyr-functions-inside-your-own-functions-or-what-is-tidyeval&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using &lt;code&gt;dplyr&lt;/code&gt; functions inside your own functions, or what is &lt;code&gt;tidyeval&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Programming with &lt;code&gt;dplyr&lt;/code&gt; has been simplified a lot. Before version &lt;code&gt;0.70&lt;/code&gt;, one needed to use &lt;code&gt;dplyr&lt;/code&gt; in conjuction with &lt;code&gt;lazyeval&lt;/code&gt; to use &lt;code&gt;dplyr&lt;/code&gt; functions inside one’s own fuctions. It was not always very easy, especially if you mixed columns and values inside your functions. Here’s the example from the March blog post:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extract_vars &amp;lt;- function(data, some_string){
    
  data %&amp;gt;%
    select_(lazyeval::interp(~contains(some_string))) -&amp;gt; data
    
  return(data)
}

extract_vars(mtcars, &amp;quot;spam&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More examples are available in &lt;a href=&#34;http://www.brodrigues.co/blog/2016-07-18-data-frame-columns-as-arguments-to-dplyr-functions/&#34;&gt;this other blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I will revisit them now with &lt;code&gt;dplyr&lt;/code&gt;’s new &lt;code&gt;tidyeval&lt;/code&gt; syntax. I’d recommend you read the &lt;em&gt;Tidy evaluation&lt;/em&gt; vignette &lt;a href=&#34;https://cran.r-project.org/web/packages/rlang/vignettes/tidy-evaluation.html&#34;&gt;here&lt;/a&gt;. This vignette is part of the &lt;code&gt;rlang&lt;/code&gt; package, which gets used under the hood by &lt;code&gt;dplyr&lt;/code&gt; for all your programming needs. Here is the function I called &lt;code&gt;simpleFunction()&lt;/code&gt;, written with the old &lt;code&gt;dplyr&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name){
  dataset %&amp;gt;%
    group_by_(col_name) %&amp;gt;%
    summarise(mean_mpg = mean(mpg)) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, &amp;quot;cyl&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     cyl mean_mpg
##   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1     4 26.66364
## 2     6 19.74286
## 3     8 15.10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the new synax, it must be rewritten a little bit:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name){
  col_name &amp;lt;- enquo(col_name)
  dataset %&amp;gt;%
    group_by(!!col_name) %&amp;gt;%
    summarise(mean_mpg = mean(mpg)) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, cyl)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     cyl mean_mpg
##   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1     4 26.66364
## 2     6 19.74286
## 3     8 15.10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What has changed? Forget the underscore versions of the usual functions such as &lt;code&gt;select_()&lt;/code&gt;, &lt;code&gt;group_by_()&lt;/code&gt;, etc. Now, you must quote the column name using &lt;code&gt;enquo()&lt;/code&gt; (or just &lt;code&gt;quo()&lt;/code&gt; if working interactively, outside a function), which returns a &lt;strong&gt;quosure&lt;/strong&gt;. This &lt;strong&gt;quosure&lt;/strong&gt; can then be evaluated using &lt;code&gt;!!&lt;/code&gt; in front of the quosure and inside the usual &lt;code&gt;dplyr&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;Let’s look at another example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name, value){
  filter_criteria &amp;lt;- lazyeval::interp(~y == x, .values=list(y = as.name(col_name), x = value))
  dataset %&amp;gt;%
    filter_(filter_criteria) %&amp;gt;%
    summarise(mean_cyl = mean(cyl)) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, &amp;quot;am&amp;quot;, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   mean_cyl
## 1 5.076923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, it’s a bit more complicated, as you needed to use &lt;code&gt;lazyeval::interp()&lt;/code&gt; to make it work. With the improved &lt;code&gt;dplyr&lt;/code&gt;, here’s how it’s done:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name, value){
  col_name &amp;lt;- enquo(col_name)
  dataset %&amp;gt;%
    filter((!!col_name) == value) %&amp;gt;%
    summarise(mean_cyl = mean(cyl)) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, am, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   mean_cyl
## 1 5.076923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much, much easier! There is something that you must pay attention to though. Notice that I’ve written:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter((!!col_name) == value)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and not:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(!!col_name == value)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have enclosed &lt;code&gt;!!col_name&lt;/code&gt; inside parentheses. I struggled with this, but thanks to help from &lt;a href=&#34;https://twitter.com/dmi3k/status/880374506291953664&#34;&gt;@dmi3k&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/_lionelhenry/status/880380691078361090&#34;&gt;@_lionelhenry&lt;/a&gt; I was able to understand what was happening (isn’t the #rstats community on twitter great?).&lt;/p&gt;
&lt;p&gt;One last thing: let’s make this function a bit more general. I hard-coded the variable &lt;code&gt;cyl&lt;/code&gt; inside the body of the function, but maybe you’d like the mean of another variable? Easy:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, group_col, mean_col, value){
  group_col &amp;lt;- enquo(group_col)
  mean_col &amp;lt;- enquo(mean_col)
  dataset %&amp;gt;%
    filter((!!group_col) == value) %&amp;gt;%
    summarise(mean((!!mean_col))) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, am, cyl, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   mean((cyl))
## 1    5.076923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;«That’s very nice Bruno, but &lt;code&gt;mean((cyl))&lt;/code&gt; in the output looks ugly as sin»&lt;/em&gt; you might think, and you’d be right. It is possible to set the name of the column in the output using &lt;code&gt;:=&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, group_col, mean_col, value){
  group_col &amp;lt;- enquo(group_col)
  mean_col &amp;lt;- enquo(mean_col)
  mean_name &amp;lt;- paste0(&amp;quot;mean_&amp;quot;, mean_col)[2]
  dataset %&amp;gt;%
    filter((!!group_col) == value) %&amp;gt;%
    summarise(!!mean_name := mean((!!mean_col))) -&amp;gt; dataset
  return(dataset)
}


simpleFunction(mtcars, am, cyl, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   mean_cyl
## 1 5.076923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get the name of the column I added this line:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean_name &amp;lt;- paste0(&amp;quot;mean_&amp;quot;, mean_col)[2]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To see what it does, try the following inside an R interpreter (remember to us &lt;code&gt;quo()&lt;/code&gt; instead of &lt;code&gt;enquo()&lt;/code&gt; outside functions!):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste0(&amp;quot;mean_&amp;quot;, quo(cyl))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;mean_~&amp;quot;   &amp;quot;mean_cyl&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;enquo()&lt;/code&gt; quotes the input, and with &lt;code&gt;paste0()&lt;/code&gt; it gets converted to a string that can be used as a column name. However, the &lt;code&gt;~&lt;/code&gt; is in the way and the output of &lt;code&gt;paste0()&lt;/code&gt; is a vector of two strings: the correct name is contained in the second element, hence the &lt;code&gt;[2]&lt;/code&gt;. There might be a more elegant way of doing that, but for now this has been working well for me.&lt;/p&gt;
&lt;p&gt;That was it folks! I do recommend you read the &lt;em&gt;Programming with dplyr&lt;/em&gt; vignette &lt;a href=&#34;https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html&#34;&gt;here&lt;/a&gt; as well as other blog posts, such as the one recommended to me by &lt;a href=&#34;https://twitter.com/dmi3k&#34;&gt;@dmi3k&lt;/a&gt; &lt;a href=&#34;http://www.win-vector.com/blog/2017/06/non-standard-evaluation-and-function-composition-in-r/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Have fun with &lt;code&gt;dplyr 0.70&lt;/code&gt;!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Make ggplot2 purrr</title>
      <link>/blog/2017-03-29-make-ggplot2-purrr/</link>
      <pubDate>Wed, 29 Mar 2017 06:45:48 +0200</pubDate>
      
      <guid>/blog/2017-03-29-make-ggplot2-purrr/</guid>
      <description>&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: I’ve included another way of saving a separate plot by group in this article, as pointed out by &lt;a href=&#34;https://twitter.com/monitus/status/849033025631297536&#34;&gt;&lt;code&gt;@monitus&lt;/code&gt;&lt;/a&gt;. Actually, this is the preferred solution; using &lt;code&gt;dplyr::do()&lt;/code&gt; is deprecated, according to Hadley Wickham &lt;a href=&#34;https://twitter.com/hadleywickham/status/719542847045636096&#34;&gt;himself&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I’ll be honest: the title is a bit misleading. I will not use &lt;code&gt;purrr&lt;/code&gt; that much in this blog post. Actually, I will use one single &lt;code&gt;purrr&lt;/code&gt; function, at the very end. I use &lt;code&gt;dplyr&lt;/code&gt; much more. However &lt;em&gt;Make ggplot2 purrr&lt;/em&gt; sounds better than &lt;em&gt;Make ggplot dplyr&lt;/em&gt; or whatever the verb for &lt;code&gt;dplyr&lt;/code&gt; would be.&lt;/p&gt;
&lt;p&gt;Also, this blog post was inspired by a stackoverflow question and in particular one of the &lt;a href=&#34;http://stackoverflow.com/a/29035145/1298051&#34;&gt;answers&lt;/a&gt;. So I don’t bring anything new to the table, but I found this stackoverflow answer so useful and so underrated (only 16 upvotes as I’m writing this!) that I wanted to write something about it.&lt;/p&gt;
&lt;p&gt;Basically the idea of this blog post is to show how to create graphs using &lt;code&gt;ggplot2&lt;/code&gt;, but by grouping by a factor variable beforehand. To illustrate this idea, let’s use the data from the &lt;a href=&#34;http://www.rug.nl/ggdc/productivity/pwt/&#34;&gt;Penn World Tables 9.0&lt;/a&gt;. The easiest way to get this data is to install the package called &lt;code&gt;pwt9&lt;/code&gt; with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pwt9&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then load the data with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;pwt9.0&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let’s load the needed packages. I am also using &lt;code&gt;ggthemes&lt;/code&gt; which makes themeing your ggplots very easy. I’ll be making &lt;a href=&#34;https://en.wikipedia.org/wiki/Edward_Tufte&#34;&gt;Tufte&lt;/a&gt;-style plots.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(ggthemes)
library(dplyr)
library(tidyr)
library(purrr)
library(pwt9)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First let’s select a list of countries:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;country_list &amp;lt;- c(&amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;United States of America&amp;quot;, &amp;quot;Luxembourg&amp;quot;, &amp;quot;Switzerland&amp;quot;, &amp;quot;Greece&amp;quot;)

small_pwt &amp;lt;- pwt9.0 %&amp;gt;%
  filter(country %in% country_list)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s us also order the countries in the data frame as I have written them in &lt;code&gt;country_list&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_pwt &amp;lt;- small_pwt %&amp;gt;%
  mutate(country = factor(country, levels = country_list, ordered = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might be wondering why this is important. At the end of the article, we are going to save the plots to disk. If we do not re-order the countries inside the data frame as in &lt;code&gt;country_list&lt;/code&gt;, the name of the files will not correspond to the correct plots!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: While this can still be interesting to know, especially if you want to order the bars of a barplot made with &lt;code&gt;ggplot2&lt;/code&gt;, I included a suggestion by &lt;a href=&#34;https://twitter.com/expersso/status/846986357792739328&#34;&gt;&lt;code&gt;@expersso&lt;/code&gt;&lt;/a&gt; that does not require your data to be ordered!&lt;/p&gt;
&lt;p&gt;Now when you want to plot the same variable by countries, say &lt;code&gt;avh&lt;/code&gt; (&lt;em&gt;Average annual hours worked by persons engaged&lt;/em&gt;), the usual way to do this is with one of &lt;code&gt;facet_wrap()&lt;/code&gt; or &lt;code&gt;facet_grid()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = small_pwt) + theme_tufte() +
  geom_line(aes(y = avh, x = year)) +
  facet_wrap(~country)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../blog/2017-03-29-make-ggplot2-purrr_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = small_pwt) + theme_tufte() +
  geom_line(aes(y = avh, x = year)) +
  facet_grid(country~.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../blog/2017-03-29-make-ggplot2-purrr_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As you can see, for this particular example, &lt;code&gt;facet_grid()&lt;/code&gt; is not very useful, but do notice its argument, &lt;code&gt;country~.&lt;/code&gt;, which is different from &lt;code&gt;facet_wrap()&lt;/code&gt;’s argument. This way, I get the graphs stacked horizontally. If I had used &lt;code&gt;facet_grid(~country)&lt;/code&gt; the graphs would be side by side and completely unreadable.&lt;/p&gt;
&lt;p&gt;Now, let’s go to the meat of this post: what if you would like to have one single graph for each country? You’d probably think of using &lt;code&gt;dplyr::group_by()&lt;/code&gt; to form the groups and then the graphs. This is the way to go, but you also have to use &lt;code&gt;dplyr::do()&lt;/code&gt;. This is because as far as I understand, &lt;code&gt;ggplot2&lt;/code&gt; is not &lt;code&gt;dplyr&lt;/code&gt;-aware, and using an arbitrary function with groups is only possible with &lt;code&gt;dplyr::do()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: As explained in the intro above, I also added the solution that uses &lt;code&gt;tidyr::nest()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Ancient, deprecated way of doing this
plots &amp;lt;- small_pwt %&amp;gt;%
  group_by(country) %&amp;gt;%
  do(plot = ggplot(data = .) + theme_tufte() +
       geom_line(aes(y = avh, x = year)) +
       ggtitle(unique(.$country)) +
       ylab(&amp;quot;Year&amp;quot;) +
       xlab(&amp;quot;Average annual hours worked by persons engaged&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is the approach that uses &lt;code&gt;tidyr::nest()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Preferred approach
plots &amp;lt;- small_pwt %&amp;gt;%
  group_by(country) %&amp;gt;%
  nest() %&amp;gt;%
  mutate(plot = map2(data, country, ~ggplot(data = .x) + theme_tufte() +
       geom_line(aes(y = avh, x = year)) +
       ggtitle(.y) +
       ylab(&amp;quot;Year&amp;quot;) +
       xlab(&amp;quot;Average annual hours worked by persons engaged&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you know &lt;code&gt;dplyr&lt;/code&gt; at least a little bit, the above lines should be easy for you to understand. But notice how we get the title of the graphs, with &lt;code&gt;ggtitle(unique(.$country))&lt;/code&gt;, which was actually the point of the stackoverflow question.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update:&lt;/em&gt; The modern version uses &lt;code&gt;tidyr::nest()&lt;/code&gt;. Its documentation tells us:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There are many possible ways one could choose to nest columns inside a data frame. &lt;code&gt;nest()&lt;/code&gt; creates a list of data frames containing all the nested variables: this seems to be the most useful form in practice.&lt;/em&gt; Let’s take a closer look at what it does exactly:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_pwt %&amp;gt;%
  group_by(country) %&amp;gt;%
  nest() %&amp;gt;%
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##                    country               data
##                      &amp;lt;ord&amp;gt;             &amp;lt;list&amp;gt;
## 1              Switzerland &amp;lt;tibble [65 x 46]&amp;gt;
## 2                  Germany &amp;lt;tibble [65 x 46]&amp;gt;
## 3                   France &amp;lt;tibble [65 x 46]&amp;gt;
## 4                   Greece &amp;lt;tibble [65 x 46]&amp;gt;
## 5               Luxembourg &amp;lt;tibble [65 x 46]&amp;gt;
## 6 United States of America &amp;lt;tibble [65 x 46]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is why I love lists in R; we get a &lt;code&gt;tibble&lt;/code&gt; where each element of the column &lt;code&gt;data&lt;/code&gt; is itself a &lt;code&gt;tibble&lt;/code&gt;. We can now apply any function that we know works on lists.&lt;/p&gt;
&lt;p&gt;What might be surprising though, is the object that is created by this code. Let’s take a look at &lt;code&gt;plots&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(plots)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##                    country               data     plot
##                      &amp;lt;ord&amp;gt;             &amp;lt;list&amp;gt;   &amp;lt;list&amp;gt;
## 1              Switzerland &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;
## 2                  Germany &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;
## 3                   France &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;
## 4                   Greece &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;
## 5               Luxembourg &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;
## 6 United States of America &amp;lt;tibble [65 x 46]&amp;gt; &amp;lt;S3: gg&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;code&gt;dplyr::do()&lt;/code&gt;’s documentation tells us, the return values get stored inside a list. And this is exactly what we get back; a list of plots! Lists are a very flexible and useful class, and you cannot spell &lt;em&gt;list&lt;/em&gt; without &lt;code&gt;purrr&lt;/code&gt; (at least not when you’re a ne&lt;code&gt;R&lt;/code&gt;d).&lt;/p&gt;
&lt;p&gt;Here are the final lines that use &lt;code&gt;purrr::map2()&lt;/code&gt; to save all these plots at once inside your working directory:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: I have changed the code below which does not require your data frame to be ordered according to the variable &lt;code&gt;country_list&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# file_names &amp;lt;- paste0(country_list, &amp;quot;.pdf&amp;quot;)

map2(paste0(plots$country, &amp;quot;.pdf&amp;quot;), plots$plot, ggsave)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As I said before, if you do not re-order the countries inside the data frame, the names of the files and the plots will not match. Try running all the code without re-ordering, you’ll see!&lt;/p&gt;
&lt;p&gt;I hope you found this post useful. You can follow me on &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog updates.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: Many thanks to the readers of this article and for their useful suggestions. I love the R community; everyday I learn something new and useful!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing brotools</title>
      <link>/blog/2017-03-27-introducing_brotools/</link>
      <pubDate>Mon, 27 Mar 2017 09:23:56 +0200</pubDate>
      
      <guid>/blog/2017-03-27-introducing_brotools/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;I’m happy to announce my first R package, called &lt;code&gt;brotools&lt;/code&gt;. This is a package that contains functions that are specific to my needs but that you might find also useful. I blogged about some of these functions, so if you follow my blog you might already be familiar with some of them. It is not on CRAN and might very well never be. The code is hosted on &lt;a href=&#34;https://bitbucket.org/b-rodrigues/brotools&#34;&gt;bitbucket&lt;/a&gt; and you can install the package with&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_bitbucket(&amp;quot;b-rodrigues/brotools&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hope you’ll find the &lt;code&gt;brotools&lt;/code&gt; useful!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lesser known purrr tricks</title>
      <link>/blog/2017-03-24-lesser_known_purrr/</link>
      <pubDate>Fri, 24 Mar 2017 12:00:00 +0100</pubDate>
      
      <guid>/blog/2017-03-24-lesser_known_purrr/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;&lt;code&gt;purrr&lt;/code&gt; is a package that extends R’s functional programming capabilities. It brings a lot of new stuff to the table and in this post I show you some of the most useful (at least to me) functions included in &lt;code&gt;purrr&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;getting-rid-of-loops-with-map&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Getting rid of loops with &lt;code&gt;map()&lt;/code&gt;&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(purrr)

numbers &amp;lt;- list(11, 12, 13, 14)

map_dbl(numbers, sqrt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.316625 3.464102 3.605551 3.741657&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might wonder why this might be preferred to a for loop? It’s a lot less verbose, and you do not need to initialise any kind of structure to hold the result. If you google “create empty list in R” you will see that this is very common. However, with the &lt;code&gt;map()&lt;/code&gt; family of functions, there is no need for an initial structure. &lt;code&gt;map_dbl()&lt;/code&gt; returns an atomic list of real numbers, but if you use &lt;code&gt;map()&lt;/code&gt; you will get a list back. Try them all out!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;map-conditionally&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Map conditionally&lt;/h2&gt;
&lt;div id=&#34;map_if&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;map_if()&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create a helper function that returns TRUE if a number is even
is_even &amp;lt;- function(x){
  !as.logical(x %% 2)
}

map_if(numbers, is_even, sqrt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 11
## 
## [[2]]
## [1] 3.464102
## 
## [[3]]
## [1] 13
## 
## [[4]]
## [1] 3.741657&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;map_at&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;map_at()&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map_at(numbers, c(1,3), sqrt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 3.316625
## 
## [[2]]
## [1] 12
## 
## [[3]]
## [1] 3.605551
## 
## [[4]]
## [1] 14&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map_if()&lt;/code&gt; and &lt;code&gt;map_at()&lt;/code&gt; have a further argument than &lt;code&gt;map()&lt;/code&gt;; in the case of &lt;code&gt;map_if()&lt;/code&gt;, a predicate function ( a function that returns &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;) and a vector of positions for &lt;code&gt;map_at()&lt;/code&gt;. This allows you to map your function only when certain conditions are met, which is also something that a lot of people google for.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;map-a-function-with-multiple-arguments&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Map a function with multiple arguments&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;numbers2 &amp;lt;- list(1, 2, 3, 4)

map2(numbers, numbers2, `+`)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 12
## 
## [[2]]
## [1] 14
## 
## [[3]]
## [1] 16
## 
## [[4]]
## [1] 18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can map two lists to a function which takes two arguments using &lt;code&gt;map_2()&lt;/code&gt;. You can even map an arbitrary number of lists to any function using &lt;code&gt;pmap()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By the way, try this in: &lt;code&gt;`+`(1,3)&lt;/code&gt; and see what happens.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dont-stop-execution-of-your-function-if-something-goes-wrong&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Don’t stop execution of your function if something goes wrong&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;possible_sqrt &amp;lt;- possibly(sqrt, otherwise = NA_real_)

numbers_with_error &amp;lt;- list(1, 2, 3, &amp;quot;spam&amp;quot;, 4)

map(numbers_with_error, possible_sqrt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051
## 
## [[4]]
## [1] NA
## 
## [[5]]
## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another very common issue is to keep running your loop even when something goes wrong. In most cases the loop simply stops at the error, but you would like it to continue and see where it failed. Try to google “skip error in a loop” or some variation of it and you’ll see that a lot of people really just want that. This is possible by combining &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;possibly()&lt;/code&gt;. Most solutions involve the use of &lt;code&gt;tryCatch()&lt;/code&gt; which I personally do not find very easy to use.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dont-stop-execution-of-your-function-if-something-goes-wrong-and-capture-the-error&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Don’t stop execution of your function if something goes wrong and capture the error&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;safe_sqrt &amp;lt;- safely(sqrt, otherwise = NA_real_)

map(numbers_with_error, safe_sqrt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [[1]]$result
## [1] 1
## 
## [[1]]$error
## NULL
## 
## 
## [[2]]
## [[2]]$result
## [1] 1.414214
## 
## [[2]]$error
## NULL
## 
## 
## [[3]]
## [[3]]$result
## [1] 1.732051
## 
## [[3]]$error
## NULL
## 
## 
## [[4]]
## [[4]]$result
## [1] NA
## 
## [[4]]$error
## &amp;lt;simpleError in .f(...): non-numeric argument to mathematical function&amp;gt;
## 
## 
## [[5]]
## [[5]]$result
## [1] 2
## 
## [[5]]$error
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;safely()&lt;/code&gt; is very similar to &lt;code&gt;possibly()&lt;/code&gt; but it returns a list of lists. An element is thus a list of the result and the accompagnying error message. If there is no error, the error component is &lt;code&gt;NULL&lt;/code&gt; if there is an error, it returns the error message.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;transpose-a-list&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Transpose a list&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;safe_result_list &amp;lt;- map(numbers_with_error, safe_sqrt)

transpose(safe_result_list)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $result
## $result[[1]]
## [1] 1
## 
## $result[[2]]
## [1] 1.414214
## 
## $result[[3]]
## [1] 1.732051
## 
## $result[[4]]
## [1] NA
## 
## $result[[5]]
## [1] 2
## 
## 
## $error
## $error[[1]]
## NULL
## 
## $error[[2]]
## NULL
## 
## $error[[3]]
## NULL
## 
## $error[[4]]
## &amp;lt;simpleError in .f(...): non-numeric argument to mathematical function&amp;gt;
## 
## $error[[5]]
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we transposed the above list. This means that we still have a list of lists, but where the first list holds all the results (which you can then access with &lt;code&gt;safe_result_list$result&lt;/code&gt;) and the second list holds all the errors (which you can access with &lt;code&gt;safe_result_list$error&lt;/code&gt;). This can be quite useful!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;apply-a-function-to-a-lower-depth-of-a-list&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Apply a function to a lower depth of a list&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;transposed_list &amp;lt;- transpose(safe_result_list)

transposed_list %&amp;gt;% 
    at_depth(2, is_null)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $result
## $result[[1]]
## [1] FALSE
## 
## $result[[2]]
## [1] FALSE
## 
## $result[[3]]
## [1] FALSE
## 
## $result[[4]]
## [1] FALSE
## 
## $result[[5]]
## [1] FALSE
## 
## 
## $error
## $error[[1]]
## [1] TRUE
## 
## $error[[2]]
## [1] TRUE
## 
## $error[[3]]
## [1] TRUE
## 
## $error[[4]]
## [1] FALSE
## 
## $error[[5]]
## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sometimes working with lists of lists can be tricky, especially when we want to apply a function to the sub-lists. This is easily done with &lt;code&gt;at_depth()&lt;/code&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;set-names-of-list-elements&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Set names of list elements&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;name_element &amp;lt;- c(&amp;quot;sqrt()&amp;quot;, &amp;quot;ok?&amp;quot;)

set_names(transposed_list, name_element)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`sqrt()`
## $`sqrt()`[[1]]
## [1] 1
## 
## $`sqrt()`[[2]]
## [1] 1.414214
## 
## $`sqrt()`[[3]]
## [1] 1.732051
## 
## $`sqrt()`[[4]]
## [1] NA
## 
## $`sqrt()`[[5]]
## [1] 2
## 
## 
## $`ok?`
## $`ok?`[[1]]
## NULL
## 
## $`ok?`[[2]]
## NULL
## 
## $`ok?`[[3]]
## NULL
## 
## $`ok?`[[4]]
## &amp;lt;simpleError in .f(...): non-numeric argument to mathematical function&amp;gt;
## 
## $`ok?`[[5]]
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reduce-a-list-to-a-single-value&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reduce a list to a single value&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;reduce(numbers, `*`)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 24024&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt; applies the function &lt;code&gt;*&lt;/code&gt; iteratively to the list of numbers. There’s also &lt;code&gt;accumulate()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;accumulate(numbers, `*`)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]    11   132  1716 24024&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which keeps the intermediary results.&lt;/p&gt;
&lt;p&gt;This function is very general, and you can reduce anything:&lt;/p&gt;
&lt;p&gt;Matrices:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mat1 &amp;lt;- matrix(rnorm(10), nrow = 2)
mat2 &amp;lt;- matrix(rnorm(10), nrow = 2)
mat3 &amp;lt;- matrix(rnorm(10), nrow = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list_mat &amp;lt;- list(mat1, mat2, mat3)

reduce(list_mat, `+`)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             [,1]       [,2]       [,3]     [,4]      [,5]
## [1,] -2.48530177  1.0110049  0.4450388 1.280802 1.3413979
## [2,]  0.07596679 -0.6872268 -0.6579242 1.615237 0.8231933&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;even data frames:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df1 &amp;lt;- as.data.frame(mat1)
df2 &amp;lt;- as.data.frame(mat2)
df3 &amp;lt;- as.data.frame(mat3)

list_df &amp;lt;- list(df1, df2, df3)

reduce(list_df, dplyr::full_join)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = c(&amp;quot;V1&amp;quot;, &amp;quot;V2&amp;quot;, &amp;quot;V3&amp;quot;, &amp;quot;V4&amp;quot;, &amp;quot;V5&amp;quot;)
## Joining, by = c(&amp;quot;V1&amp;quot;, &amp;quot;V2&amp;quot;, &amp;quot;V3&amp;quot;, &amp;quot;V4&amp;quot;, &amp;quot;V5&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           V1         V2          V3          V4         V5
## 1 -0.6264538 -0.8356286  0.32950777  0.48742905  0.5757814
## 2  0.1836433  1.5952808 -0.82046838  0.73832471 -0.3053884
## 3 -0.8969145  1.5878453 -0.08025176  0.70795473  1.9844739
## 4  0.1848492 -1.1303757  0.13242028 -0.23969802 -0.1387870
## 5 -0.9619334  0.2587882  0.19578283  0.08541773 -1.2188574
## 6 -0.2925257 -1.1521319  0.03012394  1.11661021  1.2673687&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hope you enjoyed this list of useful functions! If you enjoy the content of my blog, you can follow me on &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Lesser known dplyr tricks</title>
      <link>/blog/2017-02-17-lesser_known_tricks/</link>
      <pubDate>Wed, 08 Mar 2017 12:00:00 +0100</pubDate>
      
      <guid>/blog/2017-02-17-lesser_known_tricks/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;In this blog post I share some lesser-known (at least I believe they are) tricks that use mainly functions from &lt;code&gt;dplyr&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;removing-unneeded-columns&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Removing unneeded columns&lt;/h2&gt;
&lt;p&gt;Did you know that you can use &lt;code&gt;-&lt;/code&gt; in front of a column name to remove it from a data frame?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    select(-disp) %&amp;gt;% 
    head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;re-ordering-columns&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Re-ordering columns&lt;/h2&gt;
&lt;p&gt;Still using &lt;code&gt;select()&lt;/code&gt;, it is easy te re-order columns in your data frame:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    select(cyl, disp, hp, everything()) %&amp;gt;% 
    head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   cyl disp  hp  mpg drat    wt  qsec vs am gear carb
## Mazda RX4           6  160 110 21.0 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag       6  160 110 21.0 3.90 2.875 17.02  0  1    4    4
## Datsun 710          4  108  93 22.8 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive      6  258 110 21.4 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout   8  360 175 18.7 3.15 3.440 17.02  0  0    3    2
## Valiant             6  225 105 18.1 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As its name implies &lt;code&gt;everything()&lt;/code&gt; simply means all the other columns.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;renaming-columns-with-rename&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Renaming columns with &lt;code&gt;rename()&lt;/code&gt;&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars &amp;lt;- rename(mtcars, spam_mpg = mpg)
mtcars &amp;lt;- rename(mtcars, spam_disp = disp)
mtcars &amp;lt;- rename(mtcars, spam_hp = hp)

head(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   spam_mpg cyl spam_disp spam_hp drat    wt  qsec vs am
## Mazda RX4             21.0   6       160     110 3.90 2.620 16.46  0  1
## Mazda RX4 Wag         21.0   6       160     110 3.90 2.875 17.02  0  1
## Datsun 710            22.8   4       108      93 3.85 2.320 18.61  1  1
## Hornet 4 Drive        21.4   6       258     110 3.08 3.215 19.44  1  0
## Hornet Sportabout     18.7   8       360     175 3.15 3.440 17.02  0  0
## Valiant               18.1   6       225     105 2.76 3.460 20.22  1  0
##                   gear carb
## Mazda RX4            4    4
## Mazda RX4 Wag        4    4
## Datsun 710           4    1
## Hornet 4 Drive       3    1
## Hornet Sportabout    3    2
## Valiant              3    1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;selecting-columns-with-a-regexp&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Selecting columns with a regexp&lt;/h2&gt;
&lt;p&gt;It is easy to select the columns that start with “spam” with some helper functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    select(contains(&amp;quot;spam&amp;quot;)) %&amp;gt;% 
    head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   spam_mpg spam_disp spam_hp
## Mazda RX4             21.0       160     110
## Mazda RX4 Wag         21.0       160     110
## Datsun 710            22.8       108      93
## Hornet 4 Drive        21.4       258     110
## Hornet Sportabout     18.7       360     175
## Valiant               18.1       225     105&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;take also a look at &lt;code&gt;starts_with()&lt;/code&gt;, &lt;code&gt;ends_with()&lt;/code&gt;, &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;matches()&lt;/code&gt;, &lt;code&gt;num_range()&lt;/code&gt;, &lt;code&gt;one_of()&lt;/code&gt; and &lt;code&gt;everything()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;create-new-columns-with-mutate-and-if_else&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Create new columns with &lt;code&gt;mutate()&lt;/code&gt; and &lt;code&gt;if_else()&lt;/code&gt;&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    mutate(vs_new = if_else(
        vs == 1, 
        &amp;quot;one&amp;quot;, 
        &amp;quot;zero&amp;quot;, 
        NA_character_)) %&amp;gt;% 
    head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   spam_mpg cyl spam_disp spam_hp drat    wt  qsec vs am gear carb vs_new
## 1     21.0   6       160     110 3.90 2.620 16.46  0  1    4    4   zero
## 2     21.0   6       160     110 3.90 2.875 17.02  0  1    4    4   zero
## 3     22.8   4       108      93 3.85 2.320 18.61  1  1    4    1    one
## 4     21.4   6       258     110 3.08 3.215 19.44  1  0    3    1    one
## 5     18.7   8       360     175 3.15 3.440 17.02  0  0    3    2   zero
## 6     18.1   6       225     105 2.76 3.460 20.22  1  0    3    1    one&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might want to create a new variable conditionally on several values of another column:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    mutate(carb_new = case_when(.$carb == 1 ~ &amp;quot;one&amp;quot;,
                                .$carb == 2 ~ &amp;quot;two&amp;quot;,
                                .$carb == 4 ~ &amp;quot;four&amp;quot;,
                                 TRUE ~ &amp;quot;other&amp;quot;)) %&amp;gt;% 
    head(15)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    spam_mpg cyl spam_disp spam_hp drat    wt  qsec vs am gear carb
## 1      21.0   6     160.0     110 3.90 2.620 16.46  0  1    4    4
## 2      21.0   6     160.0     110 3.90 2.875 17.02  0  1    4    4
## 3      22.8   4     108.0      93 3.85 2.320 18.61  1  1    4    1
## 4      21.4   6     258.0     110 3.08 3.215 19.44  1  0    3    1
## 5      18.7   8     360.0     175 3.15 3.440 17.02  0  0    3    2
## 6      18.1   6     225.0     105 2.76 3.460 20.22  1  0    3    1
## 7      14.3   8     360.0     245 3.21 3.570 15.84  0  0    3    4
## 8      24.4   4     146.7      62 3.69 3.190 20.00  1  0    4    2
## 9      22.8   4     140.8      95 3.92 3.150 22.90  1  0    4    2
## 10     19.2   6     167.6     123 3.92 3.440 18.30  1  0    4    4
## 11     17.8   6     167.6     123 3.92 3.440 18.90  1  0    4    4
## 12     16.4   8     275.8     180 3.07 4.070 17.40  0  0    3    3
## 13     17.3   8     275.8     180 3.07 3.730 17.60  0  0    3    3
## 14     15.2   8     275.8     180 3.07 3.780 18.00  0  0    3    3
## 15     10.4   8     472.0     205 2.93 5.250 17.98  0  0    3    4
##    carb_new
## 1      four
## 2      four
## 3       one
## 4       one
## 5       two
## 6       one
## 7      four
## 8       two
## 9       two
## 10     four
## 11     four
## 12    other
## 13    other
## 14    other
## 15     four&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mind the &lt;code&gt;.$&lt;/code&gt; before the variable &lt;code&gt;carb&lt;/code&gt;. There is a &lt;a href=&#34;https://github.com/hadley/dplyr/issues/1965&#34;&gt;github issue&lt;/a&gt; about this, and it is already fixed in the development version of &lt;code&gt;dplyr&lt;/code&gt;, which means that in the next version of &lt;code&gt;dplyr&lt;/code&gt;, &lt;code&gt;case_when()&lt;/code&gt; will work as any other specialized &lt;code&gt;dplyr&lt;/code&gt; function inside &lt;code&gt;mutate()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;apply-a-function-to-certain-columns-only-by-rows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Apply a function to certain columns only, by rows&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
    select(am, gear, carb) %&amp;gt;%
    purrr::by_row(sum, .collate = &amp;quot;cols&amp;quot;, .to = &amp;quot;sum_am_gear_carb&amp;quot;) -&amp;gt; mtcars2
head(mtcars2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this, I had to use &lt;code&gt;purrr&lt;/code&gt;’s &lt;code&gt;by_row()&lt;/code&gt; function. You can then add this column to your original data frame:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars &amp;lt;- cbind(mtcars, &amp;quot;sum_am_gear_carb&amp;quot; = mtcars2$sum_am_gear_carb)
head(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   spam_mpg cyl spam_disp spam_hp drat    wt  qsec vs am
## Mazda RX4             21.0   6       160     110 3.90 2.620 16.46  0  1
## Mazda RX4 Wag         21.0   6       160     110 3.90 2.875 17.02  0  1
## Datsun 710            22.8   4       108      93 3.85 2.320 18.61  1  1
## Hornet 4 Drive        21.4   6       258     110 3.08 3.215 19.44  1  0
## Hornet Sportabout     18.7   8       360     175 3.15 3.440 17.02  0  0
## Valiant               18.1   6       225     105 2.76 3.460 20.22  1  0
##                   gear carb sum_am_gear_carb
## Mazda RX4            4    4                9
## Mazda RX4 Wag        4    4                9
## Datsun 710           4    1                6
## Hornet 4 Drive       3    1                4
## Hornet Sportabout    3    2                5
## Valiant              3    1                4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;use-do-to-do-any-arbitrary-operation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Use &lt;code&gt;do()&lt;/code&gt; to do any arbitrary operation&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
    group_by(cyl) %&amp;gt;% 
    do(models = lm(spam_mpg ~ drat + wt, data = .)) %&amp;gt;% 
    broom::tidy(models)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 6
## # Groups:   cyl [3]
##     cyl        term   estimate  std.error  statistic     p.value
##   &amp;lt;dbl&amp;gt;       &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1     4 (Intercept) 33.2493403 17.0987286  1.9445504 0.087727622
## 2     4        drat  1.3244329  3.4519717  0.3836743 0.711215433
## 3     4          wt -5.2400608  2.2150213 -2.3656932 0.045551615
## 4     6 (Intercept) 30.6544931  7.5141648  4.0795609 0.015103868
## 5     6        drat -0.4435744  1.1740862 -0.3778039 0.724768945
## 6     6          wt -2.9902720  1.5685053 -1.9064468 0.129274249
## 7     8 (Intercept) 29.6519180  7.0878976  4.1834574 0.001527613
## 8     8        drat -1.4698722  1.6285054 -0.9025897 0.386081744
## 9     8          wt -2.4518017  0.7985112 -3.0704664 0.010651044&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do()&lt;/code&gt; is useful when you want to use any R function (user defined functions work too!) with &lt;code&gt;dplyr&lt;/code&gt; functions. First I grouped the observations by &lt;code&gt;cyl&lt;/code&gt; and then ran a linear model for each group. Then I converted the output to a tidy data frame using &lt;code&gt;broom::tidy()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-dplyr-functions-inside-your-own-functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using &lt;code&gt;dplyr&lt;/code&gt; functions inside your own functions&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extract_vars &amp;lt;- function(data, some_string){
    
  data %&amp;gt;%
    select_(lazyeval::interp(~contains(some_string))) -&amp;gt; data
    
  return(data)
}

extract_vars(mtcars, &amp;quot;spam&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                     spam_mpg spam_disp spam_hp
## Mazda RX4               21.0     160.0     110
## Mazda RX4 Wag           21.0     160.0     110
## Datsun 710              22.8     108.0      93
## Hornet 4 Drive          21.4     258.0     110
## Hornet Sportabout       18.7     360.0     175
## Valiant                 18.1     225.0     105
## Duster 360              14.3     360.0     245
## Merc 240D               24.4     146.7      62
## Merc 230                22.8     140.8      95
## Merc 280                19.2     167.6     123
## Merc 280C               17.8     167.6     123
## Merc 450SE              16.4     275.8     180
## Merc 450SL              17.3     275.8     180
## Merc 450SLC             15.2     275.8     180
## Cadillac Fleetwood      10.4     472.0     205
## Lincoln Continental     10.4     460.0     215
## Chrysler Imperial       14.7     440.0     230
## Fiat 128                32.4      78.7      66
## Honda Civic             30.4      75.7      52
## Toyota Corolla          33.9      71.1      65
## Toyota Corona           21.5     120.1      97
## Dodge Challenger        15.5     318.0     150
## AMC Javelin             15.2     304.0     150
## Camaro Z28              13.3     350.0     245
## Pontiac Firebird        19.2     400.0     175
## Fiat X1-9               27.3      79.0      66
## Porsche 914-2           26.0     120.3      91
## Lotus Europa            30.4      95.1     113
## Ford Pantera L          15.8     351.0     264
## Ferrari Dino            19.7     145.0     175
## Maserati Bora           15.0     301.0     335
## Volvo 142E              21.4     121.0     109&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;About this last point, you can read more about it &lt;a href=&#34;http://www.brodrigues.co/blog/2016-07-18-data-frame-columns-as-arguments-to-dplyr-functions/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hope you liked this small list of tricks!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How to use jailbreakr</title>
      <link>/blog/2017-02-17-how_to_use_jailbreakr/</link>
      <pubDate>Fri, 17 Feb 2017 12:51:00 +0100</pubDate>
      
      <guid>/blog/2017-02-17-how_to_use_jailbreakr/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;div id=&#34;what-is-jailbreakr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What is &lt;code&gt;jailbreakr&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;jailbreakr&lt;/code&gt; package is probably one of the most interesting packages I came across recently. This package makes it possible to extract messy data from spreadsheets. What is meant by messy? I am sure you already had to deal with spreadsheets that contained little tables inside a single sheet for example. As far as I know, there is no simple way of extracting these tables without having to fiddle around a lot. This is now over with &lt;code&gt;jailbreakr&lt;/code&gt;. Well not entirely, because &lt;code&gt;jailbreakr&lt;/code&gt; is still in development, but it works well already. If you want to know more about the planned features, you can watch the following &lt;a href=&#34;https://channel9.msdn.com/Events/useR-international-R-User-conference/useR2016/jailbreakr-Get-out-of-Excel-free&#34;&gt;video&lt;/a&gt; by Jenny Bryan, one of the package’s authors.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;installation-and-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Installation and data&lt;/h2&gt;
&lt;p&gt;You will have to install the package from Github, as it is not on CRAN yet. &lt;a href=&#34;https://github.com/rsheets/jailbreakr&#34;&gt;Here is the Github link&lt;/a&gt;. To install the package, just run the following commands in an R console:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(c(&amp;quot;hadley/xml2&amp;quot;,
                           &amp;quot;rsheets/linen&amp;quot;,
                           &amp;quot;rsheets/cellranger&amp;quot;,
                           &amp;quot;rsheets/rexcel&amp;quot;,
                           &amp;quot;rsheets/jailbreakr&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;devtools::install_github(&amp;quot;hadley/xml2&amp;quot;)
Downloading GitHub repo hadley/xml2@master
from URL https://api.github.com/repos/hadley/xml2/zipball/master
Error in system(full, intern = quiet, ignore.stderr = quiet, ...) : 
    error in running command&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and if you’re on a GNU+Linux distribution try to run the following command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;options(unzip = &amp;quot;internal&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run &lt;code&gt;github_install()&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;As you can see, you need some other packages to make it work. Now we are going to get some data. We are going to download some time series from the European Commission, data I had to deal with recently. Download the data by clicking &lt;a href=&#34;http://ec.europa.eu/economy_finance/db_indicators/surveys/documents/series/nace2_ecfin_1701/investment_total_nsa_nace2.zip&#34;&gt;here&lt;/a&gt; and look for the spreadsheet titled &lt;code&gt;Investment_total_factors_nace2.xlsx&lt;/code&gt;. The data we are interested in is on the second sheet, named &lt;code&gt;TOT&lt;/code&gt;. You cannot import this sheet easily into R because there are four tables on the same sheet. Let us use &lt;code&gt;jailbreakr&lt;/code&gt; to get these tables out of the sheet and into nice, tidy, data frames.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;jailbreakr-to-the-rescue&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;jailbreakr&lt;/code&gt; to the rescue&lt;/h2&gt;
&lt;p&gt;The first step is to read the data in. For this, we are going to use the &lt;code&gt;rexcel&lt;/code&gt; package, which is also part of the &lt;code&gt;rsheets&lt;/code&gt; organization on Github that was set up by Jenny Brian and Rich Fitzjohn, the authors of these packages. &lt;code&gt;rexcel&lt;/code&gt; imports the sheet you want but not in a way that is immediately useful to you. It just gets the sheet into R, which makes it then possible to use &lt;code&gt;jailbreakr&lt;/code&gt;’s magic on it. First, let’s import the packages we need:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;rexcel&amp;quot;)
library(&amp;quot;jailbreakr&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to check which sheet to import. There are two sheets, and we want to import the one called &lt;code&gt;TOT&lt;/code&gt;, the second one. But is it really the second one? I have noticed that sometimes, there are hidden sheets which makes importing the one you want impossible. So first, let use use another package, &lt;code&gt;readxl&lt;/code&gt; and its function &lt;code&gt;excel_sheets()&lt;/code&gt; to make sure we are extracting the sheet we really need:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sheets &amp;lt;- readxl::excel_sheets(path_to_data)

tot_sheet &amp;lt;- which(sheets == &amp;quot;TOT&amp;quot;)

print(tot_sheet)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the sheet we want is not the second, but the third! Let us import this sheet into R now (this might take more time than you think; on my computer it takes around 10 seconds):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_sheet &amp;lt;- rexcel_read(path_to_data, sheet = tot_sheet)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can start using &lt;code&gt;jailbreakr&lt;/code&gt;. The function &lt;code&gt;split_sheet()&lt;/code&gt; is the one that splits the sheet into little tables:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tables &amp;lt;- split_sheet(my_sheet)
str(tables)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 4
##  $ :Classes &amp;#39;worksheet_view&amp;#39;, &amp;#39;R6&amp;#39; &amp;lt;worksheet_view&amp;gt;
##   Public:
##     cells: active binding
##     clone: function (deep = FALSE) 
##     data: NULL
##     dim: 34 28
##     header: NULL
##     idx: list
##     initialize: function (sheet, xr, filter, header, data) 
##     lookup: active binding
##     lookup2: active binding
##     merged: active binding
##     sheet: worksheet, R6
##     table: function (col_names = TRUE, ...) 
##     values: function () 
##     xr: cell_limits, list 
##  $ :Classes &amp;#39;worksheet_view&amp;#39;, &amp;#39;R6&amp;#39; &amp;lt;worksheet_view&amp;gt;
##   Public:
##     cells: active binding
##     clone: function (deep = FALSE) 
##     data: NULL
##     dim: 33 28
##     header: NULL
##     idx: list
##     initialize: function (sheet, xr, filter, header, data) 
##     lookup: active binding
##     lookup2: active binding
##     merged: active binding
##     sheet: worksheet, R6
##     table: function (col_names = TRUE, ...) 
##     values: function () 
##     xr: cell_limits, list 
##  $ :Classes &amp;#39;worksheet_view&amp;#39;, &amp;#39;R6&amp;#39; &amp;lt;worksheet_view&amp;gt;
##   Public:
##     cells: active binding
##     clone: function (deep = FALSE) 
##     data: NULL
##     dim: 32 28
##     header: NULL
##     idx: list
##     initialize: function (sheet, xr, filter, header, data) 
##     lookup: active binding
##     lookup2: active binding
##     merged: active binding
##     sheet: worksheet, R6
##     table: function (col_names = TRUE, ...) 
##     values: function () 
##     xr: cell_limits, list 
##  $ :Classes &amp;#39;worksheet_view&amp;#39;, &amp;#39;R6&amp;#39; &amp;lt;worksheet_view&amp;gt;
##   Public:
##     cells: active binding
##     clone: function (deep = FALSE) 
##     data: NULL
##     dim: 33 28
##     header: NULL
##     idx: list
##     initialize: function (sheet, xr, filter, header, data) 
##     lookup: active binding
##     lookup2: active binding
##     merged: active binding
##     sheet: worksheet, R6
##     table: function (col_names = TRUE, ...) 
##     values: function () 
##     xr: cell_limits, list&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tables&lt;/code&gt; is actually a list containing &lt;code&gt;worksheet_view&lt;/code&gt; objects. Take a look at the &lt;code&gt;dim&lt;/code&gt; attribute: you see the dimensions of the tables there. When I started using &lt;code&gt;jailbreakr&lt;/code&gt; I was stuck here. I was looking for the function that would extract the data frames and could not find it. Then I watched the video and I understood what I had to do: a &lt;code&gt;worksheet_view&lt;/code&gt; object has a &lt;code&gt;values()&lt;/code&gt; method that does the extraction for you. This is a bit unusual in R (it made me feel like I was using Python); maybe in future versions this &lt;code&gt;values()&lt;/code&gt; method will become a separate function of its own in the package. What happens when we use &lt;code&gt;values()&lt;/code&gt;?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;purrr&amp;quot;)
list_of_data &amp;lt;-  map(tables, (function(x)(x$values())))
map(list_of_data, head)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
##      [,1]     [,2]    [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10]
## [1,] &amp;quot;TOT&amp;quot;    NA      NA    NA    NA    NA    NA    NA    NA    NA   
## [2,] &amp;quot;DEMAND&amp;quot; 33603   33969 34334 34699 35064 35430 35795 36160 36525
## [3,] &amp;quot;FDEMT&amp;quot;  &amp;quot;FDEMN&amp;quot; NA    NA    NA    NA    NA    NA    NA    NA   
## [4,] &amp;quot;EU&amp;quot;     &amp;quot;:&amp;quot;     16.9  -1.4  20.2  34.5  31.4  37.5  39    37.3 
## [5,] &amp;quot;EA&amp;quot;     &amp;quot;:&amp;quot;     15.5  -13.1 14.8  30.9  25.1  35.2  39.2  37.1 
## [6,] &amp;quot;BE&amp;quot;     &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   42.3  43.1 
##      [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21]
## [1,] NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [2,] 36891 37256 37621 37986 38352 38717 39082 39447 39813 40178 40543
## [3,] NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [4,] 39.2  27.5  20.6  21.4  29.8  26.4  32.5  47.1  19    -1.3  23.5 
## [5,] 39.5  25.3  18.2  18.9  27.4  23    28.2  46.1  12.3  -9.3  19.3 
## [6,] 45.8  42.2  42.9  43.8  45.8  47.4  49.1  50.9  48.2  46.9  46.3 
##      [,22] [,23] [,24] [,25] [,26] [,27] [,28] 
## [1,] NA    NA    NA    NA    NA    NA    NA    
## [2,] 40908 41274 41639 42004 42369 42735 43100 
## [3,] NA    NA    NA    NA    NA    NA    NA    
## [4,] 29    22    21.1  25.6  31.8  22.9  &amp;quot;30.7&amp;quot;
## [5,] 26.2  18.6  15.7  21.7  28.8  17.3  26.6  
## [6,] 46.8  47.1  48.2  50.1  49.2  34.5  34.4  
## 
## [[2]]
##      [,1]        [,2]    [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10]
## [1,] &amp;quot;FINANCIAL&amp;quot; 33603   33969 34334 34699 35064 35430 35795 36160 36525
## [2,] &amp;quot;FFINT&amp;quot;     &amp;quot;FFINN&amp;quot; NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] &amp;quot;EU&amp;quot;        &amp;quot;:&amp;quot;     -5.1  -6.2  2.7   6.7   9     14.4  13.9  14   
## [4,] &amp;quot;EA&amp;quot;        &amp;quot;:&amp;quot;     -8.8  -13.5 -3.4  2.6   5.7   12.5  13.2  13.1 
## [5,] &amp;quot;BE&amp;quot;        &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   21.5  22.4 
## [6,] &amp;quot;BG&amp;quot;        &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;  
##      [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21]
## [1,] 36891 37256 37621 37986 38352 38717 39082 39447 39813 40178 40543
## [2,] NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] 16.4  9.4   7.4   8.1   12.4  8.4   13.6  23.4  4.1   -4    10.9 
## [4,] 16.5  8     6.8   5.1   9.9   4.8   8.4   24.3  -2.8  -10.5 9.3  
## [5,] 20.9  22.3  32.2  33.5  33.8  34.8  35    34.5  37.2  33.5  32.7 
## [6,] &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   20.8  24    27.1  28.3  33.4  37.5  37.7  26.6  30.4 
##      [,22] [,23] [,24] [,25] [,26] [,27] [,28] 
## [1,] 40908 41274 41639 42004 42369 42735 43100 
## [2,] NA    NA    NA    NA    NA    NA    NA    
## [3,] 12.4  10.2  8.8   13.4  17.4  6.2   &amp;quot;12.3&amp;quot;
## [4,] 9     7.2   5     11    13.1  -1    6.5   
## [5,] 31.5  32.3  33    31.7  32.2  19.9  20.5  
## [6,] 33.8  35.6  36    41.5  41.6  44.2  43.8  
## 
## [[3]]
##      [,1]        [,2]    [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10]
## [1,] &amp;quot;TECHNICAL&amp;quot; 33603   33969 34334 34699 35064 35430 35795 36160 36525
## [2,] &amp;quot;FTECT&amp;quot;     &amp;quot;FTECN&amp;quot; NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] &amp;quot;EU&amp;quot;        &amp;quot;:&amp;quot;     39.2  37.6  38.3  40    40.7  42.8  43.5  43.8 
## [4,] &amp;quot;EA&amp;quot;        &amp;quot;:&amp;quot;     39.7  36.2  37.5  41.2  40    44    44.8  44.9 
## [5,] &amp;quot;BE&amp;quot;        &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   58.8  58.5 
## [6,] &amp;quot;BG&amp;quot;        &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;  
##      [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21]
## [1,] 36891 37256 37621 37986 38352 38717 39082 39447 39813 40178 40543
## [2,] NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] 37    31.1  27.2  30.9  30.4  30.3  27.4  40.5  25.8  23.1  27.4 
## [4,] 37    30.3  27.4  31    29.9  29.7  24.8  41    23.4  19.5  26.4 
## [5,] 58.3  58.4  57.7  59.2  59.6  59.4  60.2  59.5  60.5  57.9  56.3 
## [6,] &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   17.3  17.5  21.1  21.5  25.3  28.2  26.1  21    25.3 
##      [,22] [,23] [,24] [,25] [,26] [,27] [,28] 
## [1,] 40908 41274 41639 42004 42369 42735 43100 
## [2,] NA    NA    NA    NA    NA    NA    NA    
## [3,] 28.9  26.3  31.3  32.1  32.1  30.2  &amp;quot;34.6&amp;quot;
## [4,] 28.5  25.9  32.1  32.4  33.1  30.2  36    
## [5,] 56.7  57.7  57.9  58.6  59.1  13.1  13.1  
## [6,] 24.6  26.8  30.4  31.9  34.1  34.8  33.7  
## 
## [[4]]
##      [,1]    [,2]    [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10] [,11]
## [1,] &amp;quot;OTHER&amp;quot; 33603   33969 34334 34699 35064 35430 35795 36160 36525 36891
## [2,] &amp;quot;FOTHT&amp;quot; &amp;quot;FOTHN&amp;quot; NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] &amp;quot;EU&amp;quot;    &amp;quot;:&amp;quot;     2.9   -0.5  3.9   3.9   1     4.1   4.7   7     7.2  
## [4,] &amp;quot;EA&amp;quot;    &amp;quot;:&amp;quot;     2.3   -4.9  1.4   1.3   -2.4  1.1   3.2   5.8   7    
## [5,] &amp;quot;BE&amp;quot;    &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   14    14.9  15.9 
## [6,] &amp;quot;BG&amp;quot;    &amp;quot;:&amp;quot;     &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;   &amp;quot;:&amp;quot;  
##      [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]
## [1,] 37256 37621 37986 38352 38717 39082 39447 39813 40178 40543 40908
## [2,] NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA   
## [3,] -1.5  6.2   8.1   7.6   1.4   2.4   13.7  -1.9  -3.2  1.1   1.1  
## [4,] -3.7  5.5   7.1   7.2   -2.2  0.4   15.5  -4.6  -8.4  0.3   -3.3 
## [5,] 16.3  22.8  23.1  22.4  24.5  25.3  25.5  26.6  26.6  24.7  24.6 
## [6,] &amp;quot;:&amp;quot;   -2.3  -0.8  2.4   2.9   3.5   4.8   5.5   2.2   3.3   3.2  
##      [,23] [,24] [,25] [,26] [,27] [,28]
## [1,] 41274 41639 42004 42369 42735 43100
## [2,] NA    NA    NA    NA    NA    NA   
## [3,] -1.6  0.9   2.7   1.9   -3.3  &amp;quot;2.1&amp;quot;
## [4,] -2.3  0.6   2.5   2.1   -5.4  1.7  
## [5,] 26.4  25.9  25    25.3  4.7   5.2  
## [6,] 5.9   7     8.2   9.6   9.4   9.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are getting really close to something useful! Now we can get the first table and do some basic cleaning to have a tidy dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset1 &amp;lt;- list_of_data[[1]]

dataset1 &amp;lt;- dataset1[-c(1:3), ]
dataset1[dataset1 == &amp;quot;:&amp;quot;] &amp;lt;- NA
colnames(dataset1) &amp;lt;- c(&amp;quot;country&amp;quot;, seq(from = 1991, to = 2017))

head(dataset1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      country 1991 1992 1993  1994 1995 1996 1997 1998 1999 2000 2001 2002
## [1,] &amp;quot;EU&amp;quot;    NA   16.9 -1.4  20.2 34.5 31.4 37.5 39   37.3 39.2 27.5 20.6
## [2,] &amp;quot;EA&amp;quot;    NA   15.5 -13.1 14.8 30.9 25.1 35.2 39.2 37.1 39.5 25.3 18.2
## [3,] &amp;quot;BE&amp;quot;    NA   NA   NA    NA   NA   NA   NA   42.3 43.1 45.8 42.2 42.9
## [4,] &amp;quot;BG&amp;quot;    NA   NA   NA    NA   NA   NA   NA   NA   NA   NA   NA   39.6
## [5,] &amp;quot;CZ&amp;quot;    NA   NA   NA    NA   NA   NA   NA   NA   NA   NA   NA   54.9
## [6,] &amp;quot;DK&amp;quot;    49.5 45   50    59.5 62.5 55.5 60.5 57.5 56   61.5 57.5 59.5
##      2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016
## [1,] 21.4 29.8 26.4 32.5 47.1 19   -1.3 23.5 29   22   21.1 25.6 31.8 22.9
## [2,] 18.9 27.4 23   28.2 46.1 12.3 -9.3 19.3 26.2 18.6 15.7 21.7 28.8 17.3
## [3,] 43.8 45.8 47.4 49.1 50.9 48.2 46.9 46.3 46.8 47.1 48.2 50.1 49.2 34.5
## [4,] 43   42.8 45.5 49.1 52.6 50.7 39.5 45.5 47.4 45.6 50.5 51.4 49.9 53.2
## [5,] 37   48.5 67.9 66.4 66.8 69.3 64.7 61   56   47.5 53   53.5 67.5 58  
## [6,] 53.5 50   59   64   63   56   33.5 57   47   48   52   45.5 40.5 36.5
##      2017  
## [1,] &amp;quot;30.7&amp;quot;
## [2,] 26.6  
## [3,] 34.4  
## [4,] 52.8  
## [5,] 59.5  
## [6,] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Et voilà! We went from a messy spreadsheet to a tidy dataset in a matter of minutes. Even though this package is still in early development and not all the features that are planned are available, the basics are there and can save you a lot of pain!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Functional programming and unit testing for data munging with R available on Leanpub</title>
      <link>/blog/2016-12-24-functional-programming-and-unit-testing-for-data-munging-with-r-available-on-leanpub/</link>
      <pubDate>Sat, 24 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-12-24-functional-programming-and-unit-testing-for-data-munging-with-r-available-on-leanpub/</guid>
      <description>&lt;p&gt;The book I&amp;rsquo;ve been working on these pasts months (you can read about it &lt;a href=&#34;http://www.brodrigues.co/2016/11/04/ive-started-writing-a-book-functional-programming-and-unit-testing-for-data-munging-with-r&#34;&gt;here&lt;/a&gt;, and read it for free &lt;a href=&#34;http://www.brodrigues.co/fput&#34;&gt;here&lt;/a&gt;) is now available on Leanpub! You can grab a copy and read it on your ebook reader or on your computer, and what&amp;rsquo;s even better is that it is available for free (but you can also decide to buy it if you really like it). Here is the link on &lt;a href=&#34;https://leanpub.com/fput&#34;&gt;Leanpub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the book, I show you the basics of functional programming, unit testing and package development for the R programming language. The end goal is to make your data tidy in a reproducible way!&lt;/p&gt;

&lt;p&gt;Just a heads up: as the book is right now, the formatting is not perfect and images are missing. This is because I use &lt;code&gt;bookdown&lt;/code&gt; to write the book and convert it to Leanpub&amp;rsquo;s markdown flavour is not trivial. I will find a solution to automate the conversion from &lt;code&gt;bookdown&lt;/code&gt;&amp;rsquo;s version to Leanpub&amp;rsquo;s markdown and try to keep both versions in sync. Of course, once the book will be finished, the version on Leanpub and on my &lt;a href=&#34;http://www.brodrigues.co/fput&#34;&gt;website&lt;/a&gt; are going to be completely identical. If you want to read it on your computer offline, you can also download a pdf from the book&amp;rsquo;s website, by clicking on the pdf icon in the top left corner.  Do not hesitate to send me an email if you want to give me feedback (just click on the red envelope in the top right corner) or tweet me &lt;a href=&#34;https://twitter.com/brodriguesco&#34;&gt;@brodriguesco&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My free book has a cover!</title>
      <link>/blog/2017-01-07-my-free-book-has-a-cover/</link>
      <pubDate>Sat, 24 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-01-07-my-free-book-has-a-cover/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m currently writing a book as a hobby. It&amp;rsquo;s titled &lt;em&gt;Functional programming and unit testing for data munging with R&lt;/em&gt; and you can get it for free &lt;a href=&#34;https://leanpub.com/fput/&#34;&gt;here&lt;/a&gt;. You can also read it online for free on my &lt;a href=&#34;http://www.brodrigues.co/fput&#34;&gt;webpage&lt;/a&gt; What&amp;rsquo;s the book about?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the teaser text:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Learn the basics of functional programming, unit testing and package development for the R programming language in order to make your data tidy!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The book now has a beautiful cover thanks to &lt;a href=&#34;https://twitter.com/putosaure&#34;&gt;@putosaure&lt;/a&gt;. Putosaure is a Paris based graphic designer who also reviews video games. He is also a very good friend of mine and I am very happy he made this beautiful cover for my book:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/cover.png&#34; width=&#34;612&#34; height=&#34;792&#34;/&gt;&lt;/p&gt;

&lt;p&gt;In it, we see a guy holding a shield with the Greek letter lambda, which also happens to be the letter to designate functional programming. I&amp;rsquo;ve added the title with the &lt;a href=&#34;http://www.dafont.com/komika-title.font&#34;&gt;Komika Title&lt;/a&gt; font.&lt;/p&gt;

&lt;p&gt;Consider this cover in beta, it&amp;rsquo;ll probably evolve some more. But I couldn&amp;rsquo;t wait to use it!&lt;/p&gt;

&lt;p&gt;I love it. Hope you&amp;rsquo;ll love it too!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Work on lists of datasets instead of individual datasets by using functional programming</title>
      <link>/blog/2016-12-21-work-on-lists-of-datasets-instead-of-individual-datasets-by-using-functional-programming/</link>
      <pubDate>Wed, 21 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-12-21-work-on-lists-of-datasets-instead-of-individual-datasets-by-using-functional-programming/</guid>
      <description>&lt;p&gt;&lt;p&gt;Analyzing a lot of datasets can be tedious. In my work, I often have to compute descriptive statistics, or plot some graphs for some variables for a lot of datasets. The variables in question have the same name accross the datasets but are measured for different years. As an example, imagine you have this situation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data2000 &amp;lt;- mtcars
data2001 &amp;lt;- mtcars&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the sake of argument, imagine that &lt;code&gt;data2000&lt;/code&gt; is data from a survey conducted in the year 2000 and &lt;code&gt;data2001&lt;/code&gt; is the same survey but conducted in the year 2001. For illustration purposes, I use the &lt;code&gt;mtcars&lt;/code&gt; dataset, but I could have used any other example. In these sort of situations, the variables are named the same in both datasets. Now if I want to check the summary statistics of a variable, I might do it by running:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(data2000$cyl)
summary(data2001$cyl)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;but this can get quite tedious, especially if instead of only having two years of data, you have 20 years. Another possibility is to merge both datasets and then check the summary statistics of the variable of interest. But this might require a lot of preprocessing, and sometimes you really just want to do a quick check, or some dirty graphs. So you might be tempted to write a loop, which would require to put these two datasets in some kind of structure, such as a list:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list_data &amp;lt;- list(&amp;quot;data2000&amp;quot; = data2000, &amp;quot;data2001&amp;quot; = data2001)&lt;/p&gt;

&lt;p&gt;for (i in 1:2){
    print(summary(list_data[[i]]$cyl))
 }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  4.000   4.000   6.000   6.188   8.000   8.000
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  4.000   4.000   6.000   6.188   8.000   8.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this also might get tedious, especially if you want to do this for a lot of different variables, and want to use different functions than &lt;code&gt;summary()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another, simpler way of doing this, is to use &lt;code&gt;purrr::map()&lt;/code&gt; or &lt;code&gt;lapply()&lt;/code&gt;. But there is a catch though: how do we specify the column we want to work on? Let’s try some things out:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(purrr)&lt;/p&gt;

&lt;p&gt;map(list_data, summary(cyl))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Error in summary(cyl) : object &amp;lsquo;cyl&amp;rsquo; not found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Maybe this will work:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map(list_data, summary, cyl)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $data2000
     mpg             cyl             disp             hp&lt;br /&gt;
Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0&lt;br /&gt;
1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5&lt;br /&gt;
Median :19.20   Median :6.000   Median :196.3   Median :123.0&lt;br /&gt;
Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7&lt;br /&gt;
3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0&lt;br /&gt;
Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0&lt;br /&gt;
     drat             wt             qsec             vs&lt;br /&gt;
Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000&lt;br /&gt;
1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000&lt;br /&gt;
Median :3.695   Median :3.325   Median :17.71   Median :0.0000&lt;br /&gt;
Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375&lt;br /&gt;
3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000&lt;br /&gt;
Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000&lt;br /&gt;
      am              gear            carb&lt;br /&gt;
Min.   :0.0000   Min.   :3.000   Min.   :1.000&lt;br /&gt;
1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000&lt;br /&gt;
Median :0.0000   Median :4.000   Median :2.000&lt;br /&gt;
Mean   :0.4062   Mean   :3.688   Mean   :2.812&lt;br /&gt;
3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000&lt;br /&gt;
Max.   :1.0000   Max.   :5.000   Max.   :8.000&lt;/p&gt;

&lt;p&gt;data2001
     mpg             cyl             disp             hp&lt;br /&gt;
Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0&lt;br /&gt;
1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5&lt;br /&gt;
Median :19.20   Median :6.000   Median :196.3   Median :123.0&lt;br /&gt;
Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7&lt;br /&gt;
3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0&lt;br /&gt;
Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0&lt;br /&gt;
     drat             wt             qsec             vs&lt;br /&gt;
Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000&lt;br /&gt;
1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000&lt;br /&gt;
Median :3.695   Median :3.325   Median :17.71   Median :0.0000&lt;br /&gt;
Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375&lt;br /&gt;
3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000&lt;br /&gt;
Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000&lt;br /&gt;
      am              gear            carb&lt;br /&gt;
Min.   :0.0000   Min.   :3.000   Min.   :1.000&lt;br /&gt;
1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000&lt;br /&gt;
Median :0.0000   Median :4.000   Median :2.000&lt;br /&gt;
Mean   :0.4062   Mean   :3.688   Mean   :2.812&lt;br /&gt;
3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000&lt;br /&gt;
Max.   :1.0000   Max.   :5.000   Max.   :8.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not quite! You get the summary statistics of every variable, &lt;code&gt;cyl&lt;/code&gt; simply gets ignored. This might be ok in our small toy example, but if you have dozens of datasets with hundreds of variables, the output becomes unreadable. The solution is to use an anonymous functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map(list_data, (function(x) summary(x$cyl)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $data2000
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  4.000   4.000   6.000   6.188   8.000   8.000&lt;/p&gt;

&lt;p&gt;$data2001
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  4.000   4.000   6.000   6.188   8.000   8.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is, in my opinion, much more readable than a loop, and the output of this is another list, so it’s easy to save it:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary_cyl &amp;lt;- map(list_data, (function(x) summary(x$cyl)))
str(summary_cyl)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 2
$ data2000:Classes &amp;lsquo;summaryDefault&amp;rsquo;, &amp;lsquo;table&amp;rsquo;  Named num [1:6] 4 4 6 6.19 8 &amp;hellip;
 .. ..- attr(&lt;em&gt;, &amp;quot;names&amp;quot;)= chr [1:6] &amp;quot;Min.&amp;quot; &amp;quot;1st Qu.&amp;quot; &amp;quot;Median&amp;quot; &amp;quot;Mean&amp;quot; &amp;hellip;
$ data2001:Classes &amp;lsquo;summaryDefault&amp;rsquo;, &amp;lsquo;table&amp;rsquo;  Named num [1:6] 4 4 6 6.19 8 &amp;hellip;
 .. ..- attr(&lt;/em&gt;, &amp;quot;names&amp;quot;)= chr [1:6] &amp;quot;Min.&amp;quot; &amp;quot;1st Qu.&amp;quot; &amp;quot;Median&amp;quot; &amp;quot;Mean&amp;quot; &amp;hellip;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the loop, you would need to “allocate” an empty list that you would fill at each iteration.&lt;/p&gt;
&lt;p&gt;So this is already nice, but wouldn’t it be nicer to simply have to type:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(list_data$cyl)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and have the summary of variable &lt;code&gt;cyl&lt;/code&gt; for each dataset in the list? Well it is possible with the following function I wrote to make my life easier:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;to_map &amp;lt;- function(func){
  function(list, column, &amp;hellip;){
    if(missing(column)){
        res &amp;lt;- purrr::map(list, (function(x) func(x, &amp;hellip;)))
      } else {
        res &amp;lt;- purrr::map(list, (function(x) func(x[column], &amp;hellip;)))
             }
    res
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By following &lt;a href=&#34;http://adv-r.had.co.nz/Function-operators.html&#34;&gt;this&lt;/a&gt; chapter of Hadley Wickham’s book, &lt;i&gt;Advanced R&lt;/i&gt;, I was able to write this function. What does it do? It basically &lt;i&gt;generalizes&lt;/i&gt; a function to work on a list of datasets instead of just on a dataset. So for example, in the case of &lt;code&gt;summary()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summarymap &amp;lt;- to_map(summary)&lt;/p&gt;

&lt;p&gt;summarymap(list_data, &amp;quot;cyl&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$data2000
     cyl&lt;br /&gt;
Min.   :4.000&lt;br /&gt;
1st Qu.:4.000&lt;br /&gt;
Median :6.000&lt;br /&gt;
Mean   :6.188&lt;br /&gt;
3rd Qu.:8.000&lt;br /&gt;
Max.   :8.000&lt;/p&gt;

&lt;p&gt;$data2001
     cyl&lt;br /&gt;
Min.   :4.000&lt;br /&gt;
1st Qu.:4.000&lt;br /&gt;
Median :6.000&lt;br /&gt;
Mean   :6.188&lt;br /&gt;
3rd Qu.:8.000&lt;br /&gt;
Max.   :8.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now everytime I want to have summary statistics for a variable, I just need to use &lt;code&gt;summarymap()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summarymap(list_data, &amp;quot;mpg&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $data2000
      mpg&lt;br /&gt;
 Min.   :10.40&lt;br /&gt;
 1st Qu.:15.43&lt;br /&gt;
 Median :19.20&lt;br /&gt;
 Mean   :20.09&lt;br /&gt;
 3rd Qu.:22.80&lt;br /&gt;
 Max.   :33.90&lt;/p&gt;

&lt;p&gt;$data2001
      mpg&lt;br /&gt;
 Min.   :10.40&lt;br /&gt;
 1st Qu.:15.43&lt;br /&gt;
 Median :19.20&lt;br /&gt;
 Mean   :20.09&lt;br /&gt;
 3rd Qu.:22.80&lt;br /&gt;
 Max.   :33.90&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If I want the summary statistics for every variable, I simply omit the column name:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summarymap(list_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$data2000
      mpg             cyl             disp             hp&lt;br /&gt;
 Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0&lt;br /&gt;
 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5&lt;br /&gt;
 Median :19.20   Median :6.000   Median :196.3   Median :123.0&lt;br /&gt;
 Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7&lt;br /&gt;
 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0&lt;br /&gt;
 Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0&lt;br /&gt;
      drat             wt             qsec             vs&lt;br /&gt;
 Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000&lt;br /&gt;
 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000&lt;br /&gt;
 Median :3.695   Median :3.325   Median :17.71   Median :0.0000&lt;br /&gt;
 Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375&lt;br /&gt;
 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000&lt;br /&gt;
 Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000&lt;br /&gt;
       am              gear            carb&lt;br /&gt;
 Min.   :0.0000   Min.   :3.000   Min.   :1.000&lt;br /&gt;
 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000&lt;br /&gt;
 Median :0.0000   Median :4.000   Median :2.000&lt;br /&gt;
 Mean   :0.4062   Mean   :3.688   Mean   :2.812&lt;br /&gt;
 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000&lt;br /&gt;
 Max.   :1.0000   Max.   :5.000   Max.   :8.000&lt;/p&gt;

&lt;p&gt;$data2001
      mpg             cyl             disp             hp&lt;br /&gt;
 Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0&lt;br /&gt;
 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5&lt;br /&gt;
 Median :19.20   Median :6.000   Median :196.3   Median :123.0&lt;br /&gt;
 Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7&lt;br /&gt;
 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0&lt;br /&gt;
 Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0&lt;br /&gt;
      drat             wt             qsec             vs&lt;br /&gt;
 Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000&lt;br /&gt;
 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000&lt;br /&gt;
 Median :3.695   Median :3.325   Median :17.71   Median :0.0000&lt;br /&gt;
 Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375&lt;br /&gt;
 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000&lt;br /&gt;
 Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000&lt;br /&gt;
       am              gear            carb&lt;br /&gt;
 Min.   :0.0000   Min.   :3.000   Min.   :1.000&lt;br /&gt;
 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000&lt;br /&gt;
 Median :0.0000   Median :4.000   Median :2.000&lt;br /&gt;
 Mean   :0.4062   Mean   :3.688   Mean   :2.812&lt;br /&gt;
 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000&lt;br /&gt;
 Max.   :1.0000   Max.   :5.000   Max.   :8.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can use any function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tablemap &amp;lt;- to_map(table)&lt;/p&gt;

&lt;p&gt;tablemap(list_data, &amp;quot;cyl&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $data2000&lt;/p&gt;

&lt;p&gt;4  6  8
11  7 14&lt;/p&gt;

&lt;p&gt;$data2001&lt;/p&gt;

&lt;p&gt;4  6  8
11  7 14&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tablemap(list_data, &amp;quot;mpg&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $data2000&lt;/p&gt;

&lt;p&gt;10.4 13.3 14.3 14.7   15 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7 19.2 19.7
   2    1    1    1    1    2    1    1    1    1    1    1    1    2    1
  21 21.4 21.5 22.8 24.4   26 27.3 30.4 32.4 33.9
   2    2    1    2    1    1    1    2    1    1&lt;/p&gt;

&lt;p&gt;$data2001&lt;/p&gt;

&lt;p&gt;10.4 13.3 14.3 14.7   15 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7 19.2 19.7
   2    1    1    1    1    2    1    1    1    1    1    1    1    2    1
  21 21.4 21.5 22.8 24.4   26 27.3 30.4 32.4 33.9
   2    2    1    2    1    1    1    2    1    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I hope you will find this little function useful, and as usual, for any comments just drop me an email by clicking the red enveloppe in the top right corner or &lt;a href=&#34;https://twitter.com/brodriguesco&#34;&gt;tweet me&lt;/a&gt;.&lt;/p&gt;
&lt;/body&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I&#39;ve started writing a &#39;book&#39;: Functional programming and unit testing for data munging with R</title>
      <link>/blog/2016-11-04-ive-started-writing-a-book-functional-programming-and-unit-testing-for-data-munging-with-r/</link>
      <pubDate>Fri, 04 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-11-04-ive-started-writing-a-book-functional-programming-and-unit-testing-for-data-munging-with-r/</guid>
      <description>&lt;p&gt;I have started writing a &amp;lsquo;book&amp;rsquo; using the awesome &lt;code&gt;bookdown&lt;/code&gt; package. In the book I explain and show why using functional programming
and putting your functions in your own packages is the way to go when you want to clean, prepare and transform large data sets.
It makes testing and documenting your code easier. You don&amp;rsquo;t need to think about managing paths either. The book is far from complete,
but I plan on working on it steadily. For now, you can read an intro to functional programming, unit testing and creating your own packages
that will hold your code. I also show you can write documentation for your functions. I am also looking for feedback; so if you have any
suggestions, do not hesitate to shoot me an email or a tweet! You can read the book by clicking &lt;a href=&#34;http://www.brodrigues.co/fput/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Merge a list of datasets together</title>
      <link>/blog/2016-07-30-merge-a-list-of-datasets-together/</link>
      <pubDate>Sat, 30 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-07-30-merge-a-list-of-datasets-together/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.brodrigues.co/2016/07/26/read-a-lot-of-datasets-at-once-with-r&#34;&gt;Last week&lt;/a&gt; I showed how to read a lot of datasets at once with R, and this week I’ll continue from there and show a very simple function that uses this list of read datasets and merges them all together.&lt;/p&gt;
&lt;p&gt;First we’ll use &lt;code&gt;read_list()&lt;/code&gt; to read all the datasets at once (for more details read &lt;a href=&#34;http://www.brodrigues.co/2016/07/26/read-a-lot-of-datasets-at-once-with-r&#34;&gt;last week’s post&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;readr&amp;quot;)
library(&amp;quot;tibble&amp;quot;)

data_files &amp;lt;- list.files(pattern = &amp;quot;.csv&amp;quot;)

print(data_files)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;data_1.csv&amp;quot; &amp;quot;data_2.csv&amp;quot; &amp;quot;data_3.csv&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list_of_data_sets &amp;lt;- read_list(data_files, read_csv)

glimpse(list_of_data_sets)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 3
##  $ data_1:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,018930679&amp;quot; &amp;quot;0,8748013128&amp;quot; &amp;quot;0,1025635934&amp;quot; &amp;quot;0,6246140983&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,0377725807&amp;quot; &amp;quot;0,5959457638&amp;quot; &amp;quot;0,4429121533&amp;quot; &amp;quot;0,558387159&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,6241767189&amp;quot; &amp;quot;0,031324594&amp;quot; &amp;quot;0,2238059868&amp;quot; &amp;quot;0,2773350732&amp;quot; ...
##  $ data_2:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,9098418493&amp;quot; &amp;quot;0,1127788509&amp;quot; &amp;quot;0,5818891392&amp;quot; &amp;quot;0,1011773532&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,7455905887&amp;quot; &amp;quot;0,4015039612&amp;quot; &amp;quot;0,6625796605&amp;quot; &amp;quot;0,029955339&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,327232932&amp;quot; &amp;quot;0,2784035673&amp;quot; &amp;quot;0,8092386735&amp;quot; &amp;quot;0,1216045306&amp;quot; ...
##  $ data_3:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,9236124896&amp;quot; &amp;quot;0,6303271761&amp;quot; &amp;quot;0,6413583054&amp;quot; &amp;quot;0,5573887416&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,2114708388&amp;quot; &amp;quot;0,6984538266&amp;quot; &amp;quot;0,0469865249&amp;quot; &amp;quot;0,9271510226&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,4941919971&amp;quot; &amp;quot;0,7391538511&amp;quot; &amp;quot;0,3876723797&amp;quot; &amp;quot;0,2815014394&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that all these datasets have the same column names. We can now merge them using this simple function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;multi_join &amp;lt;- function(list_of_loaded_data, join_func, ...){

    require(&amp;quot;dplyr&amp;quot;)

    output &amp;lt;- Reduce(function(x, y) {join_func(x, y, ...)}, list_of_loaded_data)

    return(output)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function uses &lt;code&gt;Reduce()&lt;/code&gt;. &lt;code&gt;Reduce()&lt;/code&gt; is a very important function that can be found in all functional programming languages. What does &lt;code&gt;Reduce()&lt;/code&gt; do? Let’s take a look at the following example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Reduce(`+`, c(1, 2, 3, 4, 5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Reduce()&lt;/code&gt; has several arguments, but you need to specify at least two: a function, here &lt;code&gt;+&lt;/code&gt; and a list, here &lt;code&gt;c(1, 2, 3, 4, 5)&lt;/code&gt;. The next code block shows what &lt;code&gt;Reduce()&lt;/code&gt; basically does:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 + c(1, 2, 3, 4, 5)
0 + 1 + c(2, 3, 4, 5)
0 + 1 + 2 + c(3, 4, 5)
0 + 1 + 2 + 3 + c(4, 5)
0 + 1 + 2 + 3 + 4 + c(5)
0 + 1 + 2 + 3 + 4 + 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt; had to be added as in “init”. You can also specify this “init” to &lt;code&gt;Reduce()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Reduce(`+`, c(1, 2, 3, 4, 5), init = 20)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 35&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what &lt;code&gt;multi_join()&lt;/code&gt; does, is the same operation as in the example above, but where the function is a user supplied join or merge function, and the list of datasets is the one read with &lt;code&gt;read_list()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s see what happens when we use &lt;code&gt;multi_join()&lt;/code&gt; on our list:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merged_data &amp;lt;- multi_join(list_of_data_sets, full_join)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(merged_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;tbl_df&amp;quot;     &amp;quot;tbl&amp;quot;        &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(merged_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 57
## Variables: 3
## $ col1 &amp;lt;chr&amp;gt; &amp;quot;0,018930679&amp;quot;, &amp;quot;0,8748013128&amp;quot;, &amp;quot;0,1025635934&amp;quot;, &amp;quot;0,6246140...
## $ col2 &amp;lt;chr&amp;gt; &amp;quot;0,0377725807&amp;quot;, &amp;quot;0,5959457638&amp;quot;, &amp;quot;0,4429121533&amp;quot;, &amp;quot;0,558387...
## $ col3 &amp;lt;chr&amp;gt; &amp;quot;0,6241767189&amp;quot;, &amp;quot;0,031324594&amp;quot;, &amp;quot;0,2238059868&amp;quot;, &amp;quot;0,2773350...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should make sure that all the data frames have the same column names but you can also join data frames with different column names if you give the argument &lt;code&gt;by&lt;/code&gt; to the join function. This is possible thanks to &lt;code&gt;...&lt;/code&gt; that allows you to pass further argument to &lt;code&gt;join_func()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This function was inspired by the one found on the blog &lt;a href=&#34;http://novicemetrics.blogspot.lu/2011/04/merging-multiple-data-files-into-one.html&#34;&gt;Coffee and Econometrics in the Morning&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Read a lot of datasets at once with R</title>
      <link>/blog/2016-07-26-read-a-lot-of-datasets-at-once-with-r/</link>
      <pubDate>Tue, 26 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-07-26-read-a-lot-of-datasets-at-once-with-r/</guid>
      <description>&lt;p&gt;I often have to read a lot of datasets at once using R. So I’ve wrote the following function to solve this issue:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;read_list &amp;lt;- function(list_of_datasets, read_func){

        read_and_assign &amp;lt;- function(dataset, read_func){
                dataset_name &amp;lt;- as.name(dataset)
                dataset_name &amp;lt;- read_func(dataset)
        }

        # invisible is used to suppress the unneeded output
        output &amp;lt;- invisible(
                sapply(list_of_datasets,
                           read_and_assign, read_func = read_func, simplify = FALSE, USE.NAMES = TRUE))

        # Remove the extension at the end of the data set names
        names_of_datasets &amp;lt;- c(unlist(strsplit(list_of_datasets, &amp;quot;[.]&amp;quot;))[c(T, F)])
        names(output) &amp;lt;- names_of_datasets
        return(output)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You need to supply a list of datasets as well as the function to read the datasets to &lt;code&gt;read_list&lt;/code&gt;. So for example to read in &lt;code&gt;.csv&lt;/code&gt; files, you could use &lt;code&gt;read.csv()&lt;/code&gt; (or &lt;code&gt;read_csv()&lt;/code&gt; from the &lt;code&gt;readr&lt;/code&gt; package, which I prefer to use), or &lt;code&gt;read_dta()&lt;/code&gt; from the package &lt;code&gt;haven&lt;/code&gt; for STATA files, and so on.&lt;/p&gt;
&lt;p&gt;Now imagine you have some data in your working directory. First start by saving the name of the datasets in a variable:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_files &amp;lt;- list.files(pattern = &amp;quot;.csv&amp;quot;)

print(data_files)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;data_1.csv&amp;quot; &amp;quot;data_2.csv&amp;quot; &amp;quot;data_3.csv&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can read all the data sets and save them in a list with &lt;code&gt;read_list()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;readr&amp;quot;)
library(&amp;quot;tibble&amp;quot;)

list_of_data_sets &amp;lt;- read_list(data_files, read_csv)


glimpse(list_of_data_sets)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 3
##  $ data_1:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,018930679&amp;quot; &amp;quot;0,8748013128&amp;quot; &amp;quot;0,1025635934&amp;quot; &amp;quot;0,6246140983&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,0377725807&amp;quot; &amp;quot;0,5959457638&amp;quot; &amp;quot;0,4429121533&amp;quot; &amp;quot;0,558387159&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,6241767189&amp;quot; &amp;quot;0,031324594&amp;quot; &amp;quot;0,2238059868&amp;quot; &amp;quot;0,2773350732&amp;quot; ...
##  $ data_2:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,9098418493&amp;quot; &amp;quot;0,1127788509&amp;quot; &amp;quot;0,5818891392&amp;quot; &amp;quot;0,1011773532&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,7455905887&amp;quot; &amp;quot;0,4015039612&amp;quot; &amp;quot;0,6625796605&amp;quot; &amp;quot;0,029955339&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,327232932&amp;quot; &amp;quot;0,2784035673&amp;quot; &amp;quot;0,8092386735&amp;quot; &amp;quot;0,1216045306&amp;quot; ...
##  $ data_3:Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:  19 obs. of  3 variables:
##   ..$ col1: chr [1:19] &amp;quot;0,9236124896&amp;quot; &amp;quot;0,6303271761&amp;quot; &amp;quot;0,6413583054&amp;quot; &amp;quot;0,5573887416&amp;quot; ...
##   ..$ col2: chr [1:19] &amp;quot;0,2114708388&amp;quot; &amp;quot;0,6984538266&amp;quot; &amp;quot;0,0469865249&amp;quot; &amp;quot;0,9271510226&amp;quot; ...
##   ..$ col3: chr [1:19] &amp;quot;0,4941919971&amp;quot; &amp;quot;0,7391538511&amp;quot; &amp;quot;0,3876723797&amp;quot; &amp;quot;0,2815014394&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you prefer not to have the datasets in a list, but rather import them into the global environment, you can change the above function like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;read_list &amp;lt;- function(list_of_datasets, read_func){

        read_and_assign &amp;lt;- function(dataset, read_func){
                assign(dataset, read_func(dataset), envir = .GlobalEnv)
        }

        # invisible is used to suppress the unneeded output
        output &amp;lt;- invisible(
                sapply(list_of_datasets,
                           read_and_assign, read_func = read_func, simplify = FALSE, USE.NAMES = TRUE))

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I personnally don’t like this second option, but I put it here for completeness.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data frame columns as arguments to dplyr functions</title>
      <link>/blog/2016-07-18-data-frame-columns-as-arguments-to-dplyr-functions/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-07-18-data-frame-columns-as-arguments-to-dplyr-functions/</guid>
      <description>&lt;!-- MathJax scripts --&gt;

&lt;script type=&#34;text/javascript&#34; async
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;
&lt;/script&gt;

&lt;p&gt;Suppose that you would like to create a function which does a series of computations on a data frame. You would like to pass a column as this function’s argument. Something like:&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(cars)
convertToKmh &amp;lt;- function(dataset, col_name){
  dataset$col_name &amp;lt;- dataset$speed * 1.609344
  return(dataset)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example is obviously not very interesting (you don’t need a function for this), but it will illustrate the point. You would like to append a column called &lt;code&gt;speed_in_kmh&lt;/code&gt; with the speed in kilometers per hour to this dataset, but this is what happens:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(convertToKmh(cars, &amp;quot;speed_in_kmh&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   speed dist  col_name
1     4    2  6.437376
2     4   10  6.437376
3     7    4 11.265408
4     7   22 11.265408
5     8   16 12.874752
6     9   10 14.484096&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your column is not called &lt;code&gt;speed_in_kmh&lt;/code&gt; but &lt;code&gt;col_name&lt;/code&gt;! It turns out that there is a very simple solution:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;convertToKmh &amp;lt;- function(dataset, col_name){
  dataset[col_name] &amp;lt;- dataset$speed * 1.609344
  return(dataset)
}&lt;/p&gt;

&lt;p&gt;head(convertToKmh(cars, &amp;quot;speed_in_kmh&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   speed dist speed_in_kmh
1     4    2     6.437376
2     4   10     6.437376
3     7    4    11.265408
4     7   22    11.265408
5     8   16    12.874752
6     9   10    14.484096&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can access columns with &lt;code&gt;[]&lt;/code&gt; instead of &lt;code&gt;$&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But sometimes you want to do more complex things and for example have a function that groups by a variable and then computes new variables, filters by another and so on. You would like to avoid having to hard code these variables in your function, because then why write a function and of course you would like to use &lt;code&gt;dplyr&lt;/code&gt; to do it.&lt;/p&gt;
&lt;p&gt;I often use &lt;code&gt;dplyr&lt;/code&gt; functions in my functions. For illustration purposes, consider this very simple function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name){
  require(&amp;quot;dplyr&amp;quot;)
  dataset %&amp;gt;%
    group_by(col_name) %&amp;gt;%
    summarise(mean_speed = mean(speed)) -&amp;gt; dataset
  return(dataset)
}&lt;/p&gt;

&lt;p&gt;simpleFunction(cars, &amp;quot;dist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function takes a dataset as an argument, as well as a column name. However, this does not work. You get this error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: unknown variable to group by : col_name &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;code&gt;col_name&lt;/code&gt; is passed to &lt;code&gt;simpleFunction()&lt;/code&gt; as a string, but &lt;code&gt;group_by()&lt;/code&gt; requires a variable name. So why not try to convert &lt;code&gt;col_name&lt;/code&gt; to a name?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name){
  require(&amp;quot;dplyr&amp;quot;)
  col_name &amp;lt;- as.name(col_name)
  dataset %&amp;gt;%
    group_by(col_name) %&amp;gt;%
    summarise(mean_speed = mean(speed)) -&amp;gt; dataset
  return(dataset)
}&lt;/p&gt;

&lt;p&gt;simpleFunction(cars, &amp;quot;dist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You get the same error as before:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: unknown variable to group by : col_name &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how can you pass a column name to &lt;code&gt;group_by()&lt;/code&gt;? Well, there is another version of &lt;code&gt;group_by()&lt;/code&gt; called &lt;code&gt;group_by_()&lt;/code&gt; that uses standard evaluation. You can learn more about it &lt;a href=&#34;https://cran.r-project.org/web/packages/dplyr/vignettes/nse.html&#34;&gt;here&lt;/a&gt;. Let’s take a look at what happens when we use &lt;code&gt;group_by_()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name){
  require(&amp;quot;dplyr&amp;quot;)
  dataset %&amp;gt;%
    group_by_(col_name) %&amp;gt;%
    summarise(mean_speed = mean(speed)) -&amp;gt; dataset
  return(dataset)
}&lt;/p&gt;

&lt;p&gt;simpleFunction(cars, &amp;quot;dist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;A tibble: 35 x 2
 dist mean_speed
&amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
1      2        4.0
2      4        7.0
3     10        6.5
4     14       12.0
5     16        8.0
6     17       11.0
7     18       10.0
8     20       13.5
9     22        7.0
10    24       12.0
 &amp;hellip; with 25 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can even use a formula instead of a string:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction(cars, ~dist)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; A tibble: 35 x 2
    dist mean_speed
   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
1      2        4.0
2      4        7.0
3     10        6.5
4     14       12.0
5     16        8.0
6     17       11.0
7     18       10.0
8     20       13.5
9     22        7.0
10    24       12.0
&amp;hellip; with 25 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if you want to pass column names and constants, for example to filter without hardcoding anything?&lt;/p&gt;
&lt;p&gt;Trying to do it naively will only yield pain and despair:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name, value){
  require(&amp;quot;dplyr&amp;quot;)
  dataset %&amp;gt;%
    filter_(col_name == value) %&amp;gt;%
    summarise(mean_speed = mean(speed)) -&amp;gt; dataset
  return(dataset)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; simpleFunction(cars, &amp;quot;dist&amp;quot;, 10)&lt;/p&gt;

&lt;p&gt;mean_speed
1        NaN&lt;/p&gt;

&lt;p&gt;&amp;gt; simpleFunction(cars, dist, 10)&lt;/p&gt;

&lt;p&gt;Error in col_name == value :
  comparison (1) is possible only for atomic and list types&lt;/p&gt;

&lt;p&gt;&amp;gt; simpleFunction(cars, ~dist, 10)&lt;/p&gt;

&lt;p&gt;mean_speed
1        NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To solve this issue, we need to know a little bit about two concepts, &lt;em&gt;lazy evaluation&lt;/em&gt; and &lt;em&gt;non-standard evaluation&lt;/em&gt;. I recommend you read &lt;a href=&#34;http://adv-r.had.co.nz/Computing-on-the-language.html&#34;&gt;the following document&lt;/a&gt; from Hadley Wickham’s book &lt;em&gt;Advanced R&lt;/em&gt; as well as the part on lazy evaluation &lt;a href=&#34;http://adv-r.had.co.nz/Functions.html#function-arguments&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A nice package called &lt;code&gt;lazyeval&lt;/code&gt; can help us out. We would like to make R understand that the column name is not &lt;code&gt;col_name&lt;/code&gt; but the string inside it &lt;code&gt;&amp;quot;dist&amp;quot;&lt;/code&gt;, and now we would like to use &lt;code&gt;filter()&lt;/code&gt; for &lt;code&gt;dist&lt;/code&gt; equal to &lt;code&gt;10&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;code&gt;lazyeval&lt;/code&gt; package, you’ll find the function &lt;code&gt;interp()&lt;/code&gt;. &lt;code&gt;interp()&lt;/code&gt; allows you to&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;build an expression up from a mixture of constants and variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Take a look at this example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lazyeval)
interp(~x+y, x = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ~2 + y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you get back is this nice formula that you can then use within functions. To see why this is useful, let’s look at the above example again, and make it work using &lt;code&gt;interp()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simpleFunction &amp;lt;- function(dataset, col_name, value){
  require(&amp;quot;dplyr&amp;quot;)
  require(&amp;quot;lazyeval&amp;quot;)
  filter_criteria &amp;lt;- interp(~y == x, .values=list(y = as.name(col_name), x = value))
  dataset %&amp;gt;%
    filter_(filter_criteria) %&amp;gt;%
    summarise(mean_speed = mean(speed)) -&amp;gt; dataset
  return(dataset)
}&lt;/p&gt;

&lt;p&gt;simpleFunction(cars, &amp;quot;dist&amp;quot;, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  mean_speed
1        6.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now it works! For some reason, you have to pass the column name as a string though.&lt;/p&gt;
&lt;p&gt;Sources: apart from the documents above, the following stackoverflow threads helped me out quite a lot: &lt;a href=&#34;http://stackoverflow.com/questions/28973056/in-r-pass-column-name-as-argument-and-use-it-in-function-with-dplyrmutate-a&#34;&gt;In R: pass column name as argument and use it in function with dplyr::mutate() and lazyeval::interp()&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/questions/26492280/non-standard-evaluation-nse-in-dplyrs-filter-pulling-data-from-mysql&#34;&gt;Non-standard evaluation (NSE) in dplyr’s filter_ &amp;amp; pulling data from MySQL&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Careful with tryCatch</title>
      <link>/blog/2016-06-21-careful-with-trycatch/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-06-21-careful-with-trycatch/</guid>
      <description>&lt;!-- MathJax scripts --&gt;

&lt;script type=&#34;text/javascript&#34; async
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;
&lt;/script&gt;

&lt;p&gt;&lt;code&gt;tryCatch&lt;/code&gt; is one of the functions that allows the users to handle errors in a simple way. With it, you can do things like: &lt;code&gt;if(error), then(do this)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Take the following example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sqrt(&amp;quot;a&amp;quot;)
Error in sqrt(&amp;quot;a&amp;quot;) : non-numeric argument to mathematical function&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now maybe you’d want something to happen when such an error happens. You can achieve that with &lt;code&gt;tryCatch&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tryCatch(sqrt(&amp;quot;a&amp;quot;), error=function(e) print(&amp;quot;You can&#39;t take the square root of a character, silly!&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;You can&#39;t take the square root of a character, silly!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why am I interested in &lt;code&gt;tryCatch&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;I am currently working with dates, specifically birthdays of people in my data sets. For a given mother, the birthday of her child is given in three distinct columns: a column for the child’s birth year, birth month and birth day respectively. I’ve wanted to put everything in a single column and convert the birthday to unix time (I have a very good reason to do that, but I won’t bore you with the details).&lt;/p&gt;
&lt;p&gt;Let’s create some data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother &amp;lt;- as.data.frame(list(month=12, day=1, year=1988))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In my data, there’s a lot more columns of course, such as the mother’s wage, education level, etc, but for illustration purposes, this is all that’s needed.&lt;/p&gt;
&lt;p&gt;Now, to create this birthday column:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother$birth1 &amp;lt;- as.POSIXct(paste0(as.character(mother$year), 
                                   &amp;quot;-&amp;quot;, as.character(mother$month), 
                                   &amp;quot;-&amp;quot;, as.character(mother$day)), 
                            origin=&amp;quot;1970-01-01&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and to convert it to unix time:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother$birth1 &amp;lt;- as.numeric(as.POSIXct(paste0(as.character(mother$year), 
                                              &amp;quot;-&amp;quot;, as.character(mother$month), 
                                              &amp;quot;-&amp;quot;, as.character(mother$day)),
                                       origin=&amp;quot;1970-01-01&amp;quot;))

print(mother)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   month day year    birth1
## 1    12   1 1988 596934000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s see what happens in this other example here:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother2 &amp;lt;- as.data.frame(list(month=2, day=30, year=1988))

mother2$birth1 &amp;lt;- as.POSIXct(paste0(as.character(mother2$year), 
                                    &amp;quot;-&amp;quot;, as.character(mother2$month), 
                                    &amp;quot;-&amp;quot;, as.character(mother2$day)), 
                             origin=&amp;quot;1970-01-01&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is what happens:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error in as.POSIXlt.character(x, tz, ...) : 
  character string is not in a standard unambiguous format&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error is to be expected; there is no 30th of February! It turns out that in some rare cases, weird dates like this exist in my data. Probably some encoding errors. Not a problem I thought, I could use &lt;code&gt;tryCatch&lt;/code&gt; and return &lt;code&gt;NA&lt;/code&gt; in the case of an error.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother2 &amp;lt;- as.data.frame(list(month=2, day=30, year=1988))

mother2$birth1 &amp;lt;- tryCatch(as.POSIXct(paste0(as.character(mother2$year), 
                                    &amp;quot;-&amp;quot;, as.character(mother2$month), 
                                    &amp;quot;-&amp;quot;, as.character(mother2$day)), 
                             origin=&amp;quot;1970-01-01&amp;quot;), error=function(e) NA)

print(mother2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   month day year birth1
## 1     2  30 1988     NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty great, right? Well, no. Take a look at what happens in this case:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother &amp;lt;- as.data.frame(list(month=c(12, 2), day=c(1, 30), year=c(1988, 1987)))
print(mother)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   month day year
## 1    12   1 1988
## 2     2  30 1987&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’d expect to have a correct date for the first mother and an &lt;code&gt;NA&lt;/code&gt; for the second. However, this is what happens&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mother$birth1 &amp;lt;- tryCatch(as.POSIXct(paste0(as.character(mother$year), 
                                    &amp;quot;-&amp;quot;, as.character(mother$month), 
                                    &amp;quot;-&amp;quot;, as.character(mother$day)), 
                             origin=&amp;quot;1970-01-01&amp;quot;), error=function(e) NA)

print(mother)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   month day year birth1
## 1    12   1 1988     NA
## 2     2  30 1987     NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we now have an &lt;code&gt;NA&lt;/code&gt; for both mothers! That’s actually to be expected. Indeed, this little example illustrates it well:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sqrt(c(4, 9, &amp;quot;haha&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error in sqrt(c(4, 9, &amp;quot;haha&amp;quot;)) : 
  non-numeric argument to mathematical function&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you’d like to have this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1]  2  3 NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So you could make the same mistake as myself and use tryCatch:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tryCatch(sqrt(c(4, 9, &amp;quot;haha&amp;quot;)), error=function(e) NA)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you only get &lt;code&gt;NA&lt;/code&gt; in return. That’s actually completely normal, but it took me off-guard and I spent quite some time to figure out what was happening. Especially because I had written unit tests to test my function &lt;code&gt;create_birthdays()&lt;/code&gt; that was doing the above computations and all tests were passing! The problem was that in my tests, I only had a single individual, so for a wrong date, having &lt;code&gt;NA&lt;/code&gt; for this individual was expected behaviour. But in a panel, only some individuals have a weird date like the 30th of February, but because of those, the whole column was filled with &lt;code&gt;NA&lt;/code&gt;’s! What I’m doing now is trying to either remove these weird birthdays (there are mothers whose children were born on the 99-99-9999. Documentation is lacking, but this probably means &lt;code&gt;missing value&lt;/code&gt;), or tyring to figure out how to only get &lt;code&gt;NA&lt;/code&gt;’s for the “weird” dates. I guess that the answer lies with &lt;code&gt;dplyr&lt;/code&gt;’s &lt;code&gt;group_by()&lt;/code&gt; and &lt;code&gt;mutate()&lt;/code&gt; to compute this birthdays for each individual separately.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit testing with R</title>
      <link>/blog/2016-03-31-unit-testing-with-r/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-03-31-unit-testing-with-r/</guid>
      <description>&lt;!-- MathJax scripts --&gt;

&lt;script type=&#34;text/javascript&#34; async
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;
&lt;/script&gt;

&lt;p&gt;&lt;body&gt;
&lt;p&gt;I&amp;#39;ve been introduced to unit testing while working with colleagues on quite a big project for which
we use Python.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;At first I was a bit skeptical about the need of writing unit tests, but now I must admit that I 
am seduced by the idea and by the huge time savings it allows. Naturally, I was wondering if the 
same could be achieved with R, and was quite happy to find out that it also possible to write unit
tests in R using a package called &lt;code&gt;testthat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unit tests (Not to be confused with unit root tests for time series) are small functions that test
your code and help you make sure everything is alright. I&amp;#39;m going to show how the &lt;code&gt;testthat&lt;/code&gt; 
packages works with a very trivial example, that might not do justice to the idea of
unit testing. But you&amp;#39;ll hopefully see why writing unit tests is not a waste of your time,
especially if your project gets very complex (if you&amp;#39;re writing a package for example).&lt;/p&gt;

&lt;p&gt;First, you&amp;#39;ll need to download and install &lt;code&gt;testthat&lt;/code&gt;. Some dependencies will also be installed.&lt;/p&gt;

&lt;p&gt;Now, you&amp;#39;ll need a function to test. Let&amp;#39;s suppose you&amp;#39;ve written a function that returns the
nth Fibonacci number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;r&#34;&gt;Fibonacci &amp;lt;- function(n){
    a &amp;lt;- 0
    b &amp;lt;- 1
    for (i in 1:n){
        temp &amp;lt;- b
        b &amp;lt;- a
        a &amp;lt;- a + temp
    }
    return(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You then save this function in a file, let&amp;#39;s call it &lt;code&gt;fibo.R&lt;/code&gt;. What you&amp;#39;ll probably do once you&amp;#39;ve
written this function, is to try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;r&#34;&gt;Fibonacci(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#39;ll see that the function returns the right result and continue programming. The idea behind
unit testing is write a bunch of functions that you can run after you make changes to your code,
just to check that everything is still running as it should.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s create a script called &lt;code&gt;test_fibo.R&lt;/code&gt; and write the following code in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;r&#34;&gt;test_that(&amp;quot;Test Fibo(15)&amp;quot;,{
  phi &amp;lt;- (1 + sqrt(5))/2
  psi &amp;lt;- (1 - sqrt(5))/2
  expect_equal(Fibonacci(15), (phi**15 - psi**15)/sqrt(5))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above uses Binet&amp;#39;s formula, a closed form formula that gives the nth Fibonacci number and compares it 
our implementation of the algorithm. If you didn&amp;#39;t know about Binet&amp;#39;s formula, you could simply compute some numbers
by hand and compare them to what your function returns, for example. The function &lt;code&gt;expect_equal&lt;/code&gt; is a function from the 
package &lt;code&gt;testthat&lt;/code&gt; and does exactly what it tells. We expect the result of our implementation to be equal to the result of
Binet&amp;#39;s Formula. The file &lt;code&gt;test_fibo.R&lt;/code&gt; can contain as many tests as you need. 
Also, the file that contains the tests must start with the string &lt;code&gt;test&lt;/code&gt;, so that &lt;code&gt;testthat&lt;/code&gt; knows with files it has to run.&lt;/p&gt;

&lt;p&gt;Now, we&amp;#39;re almost done, create yet another script, let&amp;#39;s call it &lt;code&gt;run_tests.R&lt;/code&gt; and write the following code in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;r&#34;&gt;library(testthat) 

source(&amp;quot;path/to/fibo.R&amp;quot;)

test_results &amp;lt;- test_dir(&amp;quot;path/to/tests&amp;quot;, reporter=&amp;quot;summary&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running these lines, and if everything goes well, you should see a message like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; library(testthat)
&amp;gt; source(&amp;quot;path/to/fibo.R&amp;quot;)
&amp;gt; test_results &amp;lt;- test_dir(&amp;quot;path/to/tests&amp;quot;, reporter=&amp;quot;summary&amp;quot;)

.
Your tests are dandy! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the small &lt;code&gt;.&lt;/code&gt; over the message? This means that one test was run successfully. You&amp;#39;ll get one dot per successful
test. If you take a look at &lt;code&gt;test_results&lt;/code&gt; you&amp;#39;ll see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; test_results
         file context          test nb failed skipped error  user system  real
1 test_fibo.R         Test Fibo(15)  1      0   FALSE FALSE 0.004      0 0.006
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#39;ll see each file and each function inside the files that were tested, and also whether the test was skipped, failed
etc. This may seem overkill for such a simple function, but imagine that you write dozens of functions that get more
and more complex over time. You might have to change a lot of lines because as time goes by you add new functionality,
but don&amp;#39;t want to break what was working. Running your unit tests each time you make changes can help you pinpoint 
regressions in your code. Unit tests can also help you start with your code. It can happen that sometimes you don&amp;#39;t
know exactly how to start; well you could start by writing a unit test that returns the result you want to have and 
then try to write the code to make that unit test pass. This is called test-driven development.&lt;/p&gt;

&lt;p&gt;I hope that this post motivated you to write unit tests and make you a better R programmer!&lt;/p&gt;

&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>